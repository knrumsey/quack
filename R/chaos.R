#' Bayesian Sparse Polynomial Chaos Expansion
#'
#' The emulation approach of Shao et al. (2017)
#'
#' @param X A dataframe or matrix of predictors scaled to be between 0 and 1
#' @param y a reponse vector
#' @param max_degree_init The maximum polynomial degree (for initial model)
#' @param max_order_init The maximum order of interaction (for initial model)
#' @param max_degree The maximum degree allowed (bounds the computation time).
#' @param lambda A parameter fed to the KIC calculations. Larger values will lead to sparser models.
#' @param rho Basis functions are only kept if their square partial correlation coefficient is bigger than rho.
#' @param verbose Logical. Should progress information be printed?
#' @details Implements the Bayesian sparse PCE method described by Shao et al. (2017).
#' @references Shao, Q., Younes, A., Fahs, M., & Mara, T. A. (2017). Bayesian sparse polynomial chaos expansion for global sensitivity analysis. Computer Methods in Applied Mechanics and Engineering, 318, 474-496.
#' @examples
#' X <- lhs::maximinLHS(500, 3)
#' y <- apply(X, 1, duqling::dms_simple) + rnorm(500, 0, 0.1)
#' fit <- bayes_chaos(X, y)
#' plot(fit)
#' @export
bayes_chaos <- function(X, y, max_degree_init=2, max_order_init=1, max_degree=6, lambda=1, rho=0, verbose=TRUE){
  n <- nrow(X)
  p <- ncol(X)
  md <- max_degree_init
  mo <- max_order_init

  mu_y <- mean(y)
  sig_y <- sd(y)
  y <- (y - mu_y)/sig_y

  res <- bayes_chaos_wrapper(X, y, n, p, md, mo, mu_y, sig_y, max_degree, lambda, rho, verbose)
  return(res)
}

bayes_chaos_wrapper <- function(X, y, n, p, md, mo, mu_y, sig_y, realmd, lambda, rho, verbose){
  # Create a list of p sequences from 1 to n
  if(verbose){
    cat("Starting model with max degree = ", md, " and max order = ", mo, "\n", sep="")
  }
  if(verbose) cat("\tComputing initial phi matrix\n")
  A_set <- generate_A(p, md, mo)
  A_deg <- apply(A_set, 1, sum)
  A_ord <- apply(A_set, 1, function(aa) sum(aa > 0))
  N_alpha <- nrow(A_set)
  if(verbose) cat("\tFound ", N_alpha, " possible basis functions.\n", sep="")
  phi <- matrix(NA, nrow=n, ncol=N_alpha)
  rr <- rep(NA, N_alpha)
  for(i in 1:N_alpha){
    curr <- rep(1, n)
    for(j in 1:p){
      curr <- curr * ss_legendre_poly(X[,j], A_set[i,j])
    }
    phi[,i] <- curr
    rr[i] <- cor(curr, y)
  }
  ord <- rev(order(rr^2))
  A_set <- A_set[ord,]
  A_deg <- A_deg[ord]
  A_ord <- A_ord[ord]
  phi <- phi[,ord]
  rr <- rr[ord]

  ### LASSO IF NEEDED?
  if(verbose) cat("\tRunning weighted LASSO...", sep="")
  lfit <- glmnet::glmnet(phi, y, penalty.factor=1-rr^2, dfmax=n-2)
  count_nonzero <- apply(lfit$beta, 2, function(bb) sum(bb != 0))
  lambda_indx <- max(which(count_nonzero < n))
  lambda_use <- lfit$lambda[lambda_indx]
  alpha_indx <- which(lfit$beta[,lambda_indx] != 0)
  if(length(alpha_indx) == 0) alpha_indx <- 1
  N_alpha <- length(alpha_indx)
  A_set <- A_set[alpha_indx,]
  A_deg <- A_deg[alpha_indx]
  A_ord <- A_ord[alpha_indx]
  phi <- phi[,alpha_indx]
  rr <- rr[alpha_indx]
  if(verbose) cat(" Keeping ", N_alpha, " basis functions\n", sep="")

  # Get partial correlation coefficients
  if(verbose) cat("\tComputing partial correlation coefficients\n")
  if(verbose) cat("\t\tFitting linear models: 0/", N_alpha, ", ", sep="")
  for(i in 2:N_alpha){
    if(N_alpha > 20 && ((i %% round(N_alpha/5)) == 0)){
      if(verbose) cat(i, "/", N_alpha, ", ",sep="")
    }
    eps_y <- lm(y ~ phi[,1:(i-1)])$residuals
    eps_p <- lm(phi[,i] ~ phi[,1:(i-1)])$residuals
    rr[i] <- cor(eps_y, eps_p)
  }

  if(any(abs(rr) > 1)){
    rr <- rr/max(abs(rr))
  }
  ord <- rev(order(rr^2))
  A_set <- A_set[ord,]
  A_deg <- A_deg[ord]
  A_ord <- A_ord[ord]
  phi <- phi[,ord]
  rr <- rr[ord]

  # Get KIC for various models
  if(verbose) cat("\n\tRanking models based on KIC\n")
  # Add coefficient column in
  phi <- cbind(rep(1, n), phi)
  A_set <- rbind(rep(0, p), A_set)
  K_trunc <- max(which(rr^2 >= rho)) + 1
  if(verbose){
    if(rho > 0) cat("\t\t Throwing out bases with low partial correlation. ", K_trunc, " remain.\n", sep="")
  }
  KIC <- rep(NA, K_trunc)
  KIC[1] <- Inf
  Caa <- diag(c((md+mo-1)*mo^2, (A_deg + A_ord -1)*A_ord^2))
  Caa_inv <- diag(1/diag(Caa))
  best <- list(k=0, KIC=Inf, map=NULL)
  for(k in 2:K_trunc){
    map_k <- estimate_map(y, phi[,1:k,drop=FALSE], Caa_inv[1:k, 1:k, drop=FALSE])
    yhat_k <- phi[,1:k]%*%map_k$a
    KIC[k] <- -2*sum(dnorm(y, yhat_k, map_k$sig, log=TRUE)) -
              2*sum(dnorm(map_k$a, 0, sqrt(diag(Caa)), log=TRUE)) -
              lambda*(k+1)*log(2*pi) + log(det(map_k$Caa_inv))
    if(KIC[k] <= best$KIC){
      best$k   <- k
      best$KIC <- KIC[k]
      best$map <- map_k
    }
  }
  if(md <= realmd - 2){
    if(max(A_deg[1:(best$k-1)]) + 1 >= md){
      res <- bayes_chaos_wrapper(X, y, n, p, md+2, mo+1, mu_y, sig_y, realmd, lambda, rho, verbose)
      return(res)
    }
  }
  #else
  obj <- list(map=best$map, phi=phi[,1:best$k,drop=FALSE],
              vars=A_set[1:best$k,,drop=FALSE],
              mu_y=mu_y, sigma_y=sig_y, KIC=best$KIC, X=X, y=y*sig_y + mu_y)
  class(obj) <- "bayes_chaos"
  return(obj)
}

#' Predict Method for class bayes_chaos
#'
#' See \code{bayes_chaos()} for details.
#'
#' @param object An object returned by the \code{bayes_chaos()} function.
#' @param newdata A dataframe of the same dimension as the training data.
#' @param samples How many posterior samples should be taken at each test point? If 0 or FALSE, then the MAP estimate is returned.
#' @details Predict function for bayes_chaos object.
#' @references Shao, Q., Younes, A., Fahs, M., & Mara, T. A. (2017). Bayesian sparse polynomial chaos expansion for global sensitivity analysis. Computer Methods in Applied Mechanics and Engineering, 318, 474-496.
#' @examples
#' X <- lhs::maximinLHS(500, 3)
#' y <- apply(X, 1, duqling::dms_simple) + rnorm(500, 0, 0.1)
#' fit <- bayes_chaos(X, y)
#' pred <- predict(fit, X)
#'
#' @export
predict.bayes_chaos <- function(object, newdata=NULL, samples=FALSE){
  if(is.null(newdata)){
    newdata <- object$X
  }
  XX <- newdata
  n <- nrow(XX)
  p <- ncol(XX)
  N_alpha <- nrow(object$vars)
  phi <- matrix(NA, nrow=n, ncol=N_alpha)
  for(i in 1:N_alpha){
    curr <- rep(1, n)
    for(j in 1:p){
      curr <- curr * ss_legendre_poly(XX[,j], object$vars[i,j])
    }
    phi[,i] <- curr
  }

  if(samples){
    pred <- matrix(NA, nrow=samples, ncol=n)
    for(i in 1:samples){
      a_sigma <- sqrt(1/diag(object$map$Caa_inv))
      a_hat <- object$map$a
      coeff <- rnorm(a_hat, a_hat, a_sigma)
      noise <- sqrt(1/rgamma(1, (n+2)/2, scale=2/(n*object$map$sig^2)))
      y_hat <- phi%*%coeff + rnorm(n, 0, noise)
      pred[i,] <- y_hat
    }
  }else{
    pred <- phi%*%object$map$a
  }
  pred <- object$mu_y + object$sigma_y * pred
  return(pred)
}

#' Plot Method for class bayes_chaos
#'
#' See \code{bayes_chaos()} for details.
#'
#' @param x An object returned by the \code{bayes_chaos()} function.
#' @param ... additional arguments passed to \code{plot}
#' @details Plot function for bayes_chaos object.
#' @references Shao, Q., Younes, A., Fahs, M., & Mara, T. A. (2017). Bayesian sparse polynomial chaos expansion for global sensitivity analysis. Computer Methods in Applied Mechanics and Engineering, 318, 474-496.
#' @examples
#' X <- lhs::maximinLHS(500, 3)
#' y <- apply(X, 1, duqling::dms_simple) + rnorm(500, 0, 0.1)
#' fit <- bayes_chaos(X, y)
#' plot(fit)
#' @export
plot.bayes_chaos <- function(x, ...){
  pred <- predict(x, x$X, samples=1000)
  yhat <- colMeans(pred)
  plot(x$y, yhat, ...)
  abline(0, 1, lwd=2, col='orange')

  ci <- apply(pred, 2, function(yy) quantile(yy, c(0.025, 0.975)))
  for(i in 1:ncol(ci)){
    segments(x$y[i], ci[1,i], x$y[i], ci[2,i])
  }
}






