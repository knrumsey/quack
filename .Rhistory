gs4_oauth_app()
?gs4_oauth_app
?gs4_oauth_app
sheets_deauth()
gs4_deauth()
rsconnect::deployApp('../Pile_Manager')
rsconnect::setAccountInfo(name='knrumsey', token='D4C90AE28077214D2D52FCDF2B851F16', secret='jeup5+kkkkr4UPh4nsHVpykiS6JclkIzb4BRQlwc')
library(rsconnect)
rsconnect::deployApp("../Pile_Manager")
rsconnect::setAccountInfo(name='knrumsey',
token='D4C90AE28077214D2D52FCDF2B851F16',
secret='jeup5+kkkkr4UPh4nsHVpykiS6JclkIzb4BRQlwc')
library(rsconnect)
rsconnect::deployApp("../Pile_Manager")
library(rsconnect)
rsconnect::deployApp("../Pile_Manager")
library(rsconnect)
rsconnect::deployApp("../Pile_Manager")
runApp()
runApp()
?downloadButton
library(shinyjs)
toggleState
?toggleState
?observe
runApp()
runApp()
runApp()
?disable
runApp()
runApp()
?downloadButton
runApp()
?enable
runApp()
rsconnect::setAccountInfo(name='knrumsey',
token='D4C90AE28077214D2D52FCDF2B851F16',
secret='jeup5+kkkkr4UPh4nsHVpykiS6JclkIzb4BRQlwc')
library(rsconnect)
rsconnect::deployApp("../Pile_Manager")
runApp()
library(mvtnorm)
1 %in% NULL
#' @param verbose should information on status be printed
#' @param crit a subset of c("aic", "bic", "hqic") corresponding to Aikike's, Bayesian and Hanaan-Quinn information criteria.
#' @param ... additional parameters passed to get_constMP (if norm=TRUE)
#' @return a list with components corresponding to the fit using the number of components specified by `K`
#' @examples
#' x <- rnorm(10)
#' dMP(x, w1=5, w2=2)
#' X <- matrix(rnorm(10*30), nrow=30)
#' apply(X, 1, dMP, w1=5, w2=2)
#' @export
mvn_mix <- function(X, K=1:3, epsilon=1e-5, max_iter=2000, verbose=FALSE, crit=NULL){
out <- list()
for(k in k_comp){
N_comp <- k
# Initialize model
SX <- cov(X)
a_n <- function(n, kap=0.75) n^(-kap)
pi <- (tmp <- runif(N_comp))/sum(tmp)
mu <- sigma <- list()
for(j in 1:N_comp){
mu[[j]]    <- X[sample(nrow(X), 1),]
sigma[[j]] <- rWishart(1, df=ncol(X)+2, SX)[,,1]
}
n <- nrow(X)
p <- N_comp
d <- nrow(SX)
pi_ij <- matrix(NA, nrow=n, ncol=p)
iter <- 1
tol <- Inf
log_lik <- rep(NA, max_iter)
while(tol > epsilon & iter < max_iter){
#E-STEP
for(i in 1:n){
for(j in 1:p){
xi <- X[i,]
pi_ij[i,j] <- pi[j] * dmvnorm(as.numeric(xi), as.numeric(mu[[j]]), sigma[[j]])
}
}
for(i in 1:n){
pi_ij[i,] <- pi_ij[i,]/sum(pi_ij[i,])
}
# M-STEP
Sj <- list()
for(j in 1:p){
tmp <- matrix(0, nrow=d, ncol=d)
for(i in 1:n){
xi <- X[i,]
tmp <- tmp + pi_ij[i,j]*tcrossprod(xi - mu[[j]])
}
Sj[[j]] <- tmp
}
#Update component probabilities
pi <- apply(pi_ij, 2, mean)
#Update covariance matrices
for(j in 1:p){
sigma[[j]] <- (2*a_n(n)*SX + Sj[[j]])/(2*a_n(n) + n*pi[j])
}
#Update mean vectors
for(j in 1:p){
tmp <- 0
for(i in 1:n){
xi <- X[i,]
tmp <- tmp + pi_ij[i,j]*xi
}
mu[[j]] <- tmp/(n*pi[j])
}
#Compute log likelihood
log_lik[iter] <- 0
for(i in 1:n){
tmp <- 0
xi <- X[i,]
for(j in 1:p){
tmp <- tmp + pi[j]*dmvnorm(xi, mu[[j]], sigma[[j]])
}
log_lik[iter] <- log_lik[iter] + log(tmp)
}
if((iter %% 10) == 0){
if(verbose)
cat("K: ", k, "\nIteration: ", iter, "\ntol: ", tol, "\n\n")
}
if(iter > 1){
tol <- log_lik[iter] - log_lik[iter - 1]
}
iter <- iter + 1
}
log_lik <- log_lik[1:(iter - 1)]
out[[k]] <- list(log_lik = log_lik,
pi = pi,
mu = mu,
sigma = sigma)
}
if(!is.null(crit)){
Kmax <- length(out)
bic <- ll <- rep(NA, Kmax)
aic <- hqic <- rep(NA, Kmax)
k <- 1
bic[1] <- -2*sum(log(dmvnorm(X, apply(X, 2, mean), cov(X)))) +
(k-1 + 5*k + 5*(5+1)/2*k)*log(nrow(X))
aic[1] <- -2*sum(log(dmvnorm(X, apply(X, 2, mean), cov(X)))) +
(k-1 + 5*k + 5*(5+1)/2*k)*2
hqic[1] <- -2*sum(log(dmvnorm(X, apply(X, 2, mean), cov(X)))) +
(k-1 + 5*k + 5*(5+1)/2*k)*2*log(log(n))
ll[1] <- sum(log(dmvnorm(X, apply(X, 2, mean), cov(X))))
for(k in 2:Kmax){
tmp <- out[[k]]$log_lik
bic[k] <- -2*max(tmp) + (k-1 + 5*k + 5*(5+1)/2*k)*log(nrow(X))
aic[k] <- -2*max(tmp) + (k-1 + 5*k + 5*(5+1)/2*k)*2
hqic[k]<- -2*max(tmp) + (k-1 + 5*k + 5*(5+1)/2*k)*2*log(log(nrow(X)))
ll[k] <- max(tmp)
}
out2 <- list(fits=out)
if("aic" %in% crit){
out2$aic <- aic
}
if("bic" %in% crit){
out2$bic <- bic
}
if("hqic" %in% crit){
out2$hqic <- hqic
}
return(out2)
}
return(out)
}
X <- rmvtnorm(100, c(0, 0), matrix(c(1, 0.4, 0.4, 1), byrow=TRUE))
X <- rmvnorm(100, c(0, 0), matrix(c(1, 0.4, 0.4, 1), byrow=TRUE))
X <- rmvtnorm(100, c(0, 0), matrix(c(1, 0.4, 0.4, 1), byrow=TRUE, nrow=2))
X <- rmvnorm(100, c(0, 0), matrix(c(1, 0.4, 0.4, 1), byrow=TRUE, nrow=2))
X
rbind(X, X)
X <- rmvnorm(100, c(0, 0), matrix(c(1, 0.4, 0.4, 1), byrow=TRUE, nrow=2))
X <- rbind(X, rmvnorm(100, c(0.2, 0.1), matrix(c(1, -0.3, -0.3, 1), byrow=TRUE, nrow=2)))
dim(X)
mvn_mix(X, 2, crit=c("bic", "aic", "hqic"))
#' @param verbose should information on status be printed
#' @param crit a subset of c("aic", "bic", "hqic") corresponding to Aikike's, Bayesian and Hanaan-Quinn information criteria.
#' @param ... additional parameters passed to get_constMP (if norm=TRUE)
#' @return a list with components corresponding to the fit using the number of components specified by `K`
#' @examples
#' x <- rnorm(10)
#' dMP(x, w1=5, w2=2)
#' X <- matrix(rnorm(10*30), nrow=30)
#' apply(X, 1, dMP, w1=5, w2=2)
#' @export
mvn_mix <- function(X, K=1:3, epsilon=1e-5, max_iter=2000, verbose=FALSE, crit=NULL){
out <- list()
for(k in K){
N_comp <- k
# Initialize model
SX <- cov(X)
a_n <- function(n, kap=0.75) n^(-kap)
pi <- (tmp <- runif(N_comp))/sum(tmp)
mu <- sigma <- list()
for(j in 1:N_comp){
mu[[j]]    <- X[sample(nrow(X), 1),]
sigma[[j]] <- rWishart(1, df=ncol(X)+2, SX)[,,1]
}
n <- nrow(X)
p <- N_comp
d <- nrow(SX)
pi_ij <- matrix(NA, nrow=n, ncol=p)
iter <- 1
tol <- Inf
log_lik <- rep(NA, max_iter)
while(tol > epsilon & iter < max_iter){
#E-STEP
for(i in 1:n){
for(j in 1:p){
xi <- X[i,]
pi_ij[i,j] <- pi[j] * dmvnorm(as.numeric(xi), as.numeric(mu[[j]]), sigma[[j]])
}
}
for(i in 1:n){
pi_ij[i,] <- pi_ij[i,]/sum(pi_ij[i,])
}
# M-STEP
Sj <- list()
for(j in 1:p){
tmp <- matrix(0, nrow=d, ncol=d)
for(i in 1:n){
xi <- X[i,]
tmp <- tmp + pi_ij[i,j]*tcrossprod(xi - mu[[j]])
}
Sj[[j]] <- tmp
}
#Update component probabilities
pi <- apply(pi_ij, 2, mean)
#Update covariance matrices
for(j in 1:p){
sigma[[j]] <- (2*a_n(n)*SX + Sj[[j]])/(2*a_n(n) + n*pi[j])
}
#Update mean vectors
for(j in 1:p){
tmp <- 0
for(i in 1:n){
xi <- X[i,]
tmp <- tmp + pi_ij[i,j]*xi
}
mu[[j]] <- tmp/(n*pi[j])
}
#Compute log likelihood
log_lik[iter] <- 0
for(i in 1:n){
tmp <- 0
xi <- X[i,]
for(j in 1:p){
tmp <- tmp + pi[j]*dmvnorm(xi, mu[[j]], sigma[[j]])
}
log_lik[iter] <- log_lik[iter] + log(tmp)
}
if((iter %% 10) == 0){
if(verbose)
cat("K: ", k, "\nIteration: ", iter, "\ntol: ", tol, "\n\n")
}
if(iter > 1){
tol <- log_lik[iter] - log_lik[iter - 1]
}
iter <- iter + 1
}
log_lik <- log_lik[1:(iter - 1)]
out[[k]] <- list(log_lik = log_lik,
pi = pi,
mu = mu,
sigma = sigma)
}
if(!is.null(crit)){
Kmax <- length(out)
bic <- ll <- rep(NA, Kmax)
aic <- hqic <- rep(NA, Kmax)
k <- 1
bic[1] <- -2*sum(log(dmvnorm(X, apply(X, 2, mean), cov(X)))) +
(k-1 + 5*k + 5*(5+1)/2*k)*log(nrow(X))
aic[1] <- -2*sum(log(dmvnorm(X, apply(X, 2, mean), cov(X)))) +
(k-1 + 5*k + 5*(5+1)/2*k)*2
hqic[1] <- -2*sum(log(dmvnorm(X, apply(X, 2, mean), cov(X)))) +
(k-1 + 5*k + 5*(5+1)/2*k)*2*log(log(n))
ll[1] <- sum(log(dmvnorm(X, apply(X, 2, mean), cov(X))))
for(k in 2:Kmax){
tmp <- out[[k]]$log_lik
bic[k] <- -2*max(tmp) + (k-1 + 5*k + 5*(5+1)/2*k)*log(nrow(X))
aic[k] <- -2*max(tmp) + (k-1 + 5*k + 5*(5+1)/2*k)*2
hqic[k]<- -2*max(tmp) + (k-1 + 5*k + 5*(5+1)/2*k)*2*log(log(nrow(X)))
ll[k] <- max(tmp)
}
out2 <- list(fits=out)
if("aic" %in% crit){
out2$aic <- aic
}
if("bic" %in% crit){
out2$bic <- bic
}
if("hqic" %in% crit){
out2$hqic <- hqic
}
return(out2)
}
return(out)
}
mvn_mix(X, 2, crit=c("bic", "aic", "hqic"))
mvn_mix(X, 1:2, crit=c("bic", "aic", "hqic"), verbose=TRUE)
plot(X)
X <- rmvnorm(100, c(0, 0), matrix(c(1, 0.4, 0.4, 1), byrow=TRUE, nrow=2))
X <- rbind(X, rmvnorm(300, c(1, 1.5), matrix(c(1, -0.7, -0.7, 1), byrow=TRUE, nrow=2)))
foo <- mvn_mix(X, 1:2, crit=c("bic", "aic", "hqic"), verbose=TRUE)
foo
plot(K)
plot(X)
foo$fits[[1]]
foo$fits[[2]]
cov(X)
foo$fits[[1]]$sigma
#' @param verbose should information on status be printed
#' @param crit a subset of c("aic", "bic", "hqic") corresponding to Aikike's, Bayesian and Hanaan-Quinn information criteria.
#' @param ... additional parameters passed to get_constMP (if norm=TRUE)
#' @return a list with components corresponding to the fit using the number of components specified by `K`
#' @examples
#' x <- rnorm(10)
#' dMP(x, w1=5, w2=2)
#' X <- matrix(rnorm(10*30), nrow=30)
#' apply(X, 1, dMP, w1=5, w2=2)
#' @export
mvn_mix <- function(X, K=1:3, epsilon=1e-5, max_iter=2000, verbose=FALSE, crit=NULL){
out <- list()
for(k in K){
N_comp <- k
# Initialize model
SX <- cov(X)
a_n <- function(n, kap=0.75) n^(-kap)
pi <- (tmp <- runif(N_comp))/sum(tmp)
mu <- sigma <- list()
for(j in 1:N_comp){
mu[[j]]    <- X[sample(nrow(X), 1),]
sigma[[j]] <- rWishart(1, df=ncol(X)+2, SX)[,,1]
}
n <- nrow(X)
p <- N_comp
d <- nrow(SX)
pi_ij <- matrix(NA, nrow=n, ncol=p)
iter <- 1
tol <- Inf
log_lik <- rep(NA, max_iter)
while(tol > epsilon & iter < max_iter){
#E-STEP
for(i in 1:n){
for(j in 1:p){
xi <- X[i,]
pi_ij[i,j] <- pi[j] * dmvnorm(as.numeric(xi), as.numeric(mu[[j]]), sigma[[j]])
}
}
for(i in 1:n){
pi_ij[i,] <- pi_ij[i,]/sum(pi_ij[i,])
}
# M-STEP
Sj <- list()
for(j in 1:p){
tmp <- matrix(0, nrow=d, ncol=d)
for(i in 1:n){
xi <- X[i,]
tmp <- tmp + pi_ij[i,j]*tcrossprod(xi - mu[[j]])
}
Sj[[j]] <- tmp
}
#Update component probabilities
pi <- apply(pi_ij, 2, mean)
#Update covariance matrices
for(j in 1:p){
sigma[[j]] <- (2*a_n(n)*SX + Sj[[j]])/(2*a_n(n) + n*pi[j])
}
#Update mean vectors
for(j in 1:p){
tmp <- 0
for(i in 1:n){
xi <- X[i,]
tmp <- tmp + pi_ij[i,j]*xi
}
mu[[j]] <- tmp/(n*pi[j])
}
#Compute log likelihood
log_lik[iter] <- 0
for(i in 1:n){
tmp <- 0
xi <- X[i,]
for(j in 1:p){
tmp <- tmp + pi[j]*dmvnorm(xi, mu[[j]], sigma[[j]])
}
log_lik[iter] <- log_lik[iter] + log(tmp)
}
if((iter %% 10) == 0){
if(verbose)
cat("K: ", k, "\nIteration: ", iter, "\ntol: ", tol, "\n\n")
}
if(iter > 1){
tol <- log_lik[iter] - log_lik[iter - 1]
}
iter <- iter + 1
}
log_lik <- log_lik[1:(iter - 1)]
out[[k]] <- list(log_lik = log_lik,
pi = pi,
mu = mu,
sigma = sigma)
}
if(!is.null(crit)){
nvar <- ncol(X)
Kmax <- length(out)
bic <- ll <- rep(NA, Kmax)
aic <- hqic <- rep(NA, Kmax)
k <- 1
bic[1] <- -2*sum(log(dmvnorm(X, apply(X, 2, mean), cov(X)))) +
(k-1 + nvar*k + nvar*(nvar+1)/2*k)*log(nrow(X))
aic[1] <- -2*sum(log(dmvnorm(X, apply(X, 2, mean), cov(X)))) +
(k-1 + nvar*k + nvar*(nvar+1)/2*k)*2
hqic[1] <- -2*sum(log(dmvnorm(X, apply(X, 2, mean), cov(X)))) +
(k-1 + nvar*k + nvar*(nvar+1)/2*k)*2*log(log(n))
ll[1] <- sum(log(dmvnorm(X, apply(X, 2, mean), cov(X))))
for(k in 2:Kmax){
tmp <- out[[k]]$log_lik
bic[k] <- -2*max(tmp) + (k-1 + nvar*k + nvar*(nvar+1)/2*k)*log(nrow(X))
aic[k] <- -2*max(tmp) + (k-1 + nvar*k + nvar*(nvar+1)/2*k)*2
hqic[k]<- -2*max(tmp) + (k-1 + nvar*k + nvar*(nvar+1)/2*k)*2*log(log(nrow(X)))
ll[k] <- max(tmp)
}
out2 <- list(fits=out)
if("aic" %in% crit){
out2$aic <- aic
}
if("bic" %in% crit){
out2$bic <- bic
}
if("hqic" %in% crit){
out2$hqic <- hqic
}
out2$ll <- ll
return(out2)
}
return(out)
}
foo <- mvn_mix(X, 1:2, crit=c("bic", "aic", "hqic"), verbose=TRUE)
cov(X)
foo$fits$[[1]]$sigma
foo$fits[[1]]$sigma
foot$fits[[2]]$sigma
foo$fits[[2]]$sigma
foo$fits[[2]]$mu
foo$fits[[2]]$pi
foo$fits[[2]]$mu
document()
library(devtools)
library(roxygen2)
document()
document()
n1 <- 100
mu1 <- c(0, 0)
sigma1 <- matrix(c(1, 0.5, 0.5, 1), nrow=2, byrow=TRUE)
X1 <- mvtnorm::mvnorm(n1, mu1, sigma1)
X1 <- mvtnorm::rmvnorm(n1, mu1, sigma1)
n1 <- 100
mu1 <- c(0, 0)
sigma1 <- matrix(c(1, 0.5, 0.5, 1), nrow=2, byrow=TRUE)
X1 <- mvtnorm::rmvnorm(n1, mu1, sigma1)
n2 <- 200
mu2 <- c(1, 1.5)
sigma2 <- matrix(c(1, 0.5, 0.5, 1), nrow=2, byrow=TRUE)
X2 <- mvtnorm::rmvnorm(n2, mu2, sigma2)
X <- rbind(X1, X2)
plot(X)
n1 <- 100
mu1 <- c(0, 0)
sigma1 <- matrix(c(1, 0.5, 0.5, 1), nrow=2, byrow=TRUE)
X1 <- mvtnorm::rmvnorm(n1, mu1, sigma1)
n2 <- 200
mu2 <- c(1, 1.5)
sigma2 <- matrix(c(1, -0.7, -0.7, 1), nrow=2, byrow=TRUE)
X2 <- mvtnorm::rmvnorm(n2, mu2, sigma2)
X <- rbind(X1, X2)
plot(X)
n1 <- 300
mu1 <- c(0, 0)
sigma1 <- matrix(c(1, 0.5, 0.5, 1), nrow=2, byrow=TRUE)
X1 <- mvtnorm::rmvnorm(n1, mu1, sigma1)
n2 <- 500
mu2 <- c(1, 1.5)
sigma2 <- matrix(c(1, -0.7, -0.7, 1), nrow=2, byrow=TRUE)
X2 <- mvtnorm::rmvnorm(n2, mu2, sigma2)
X <- rbind(X1, X2)
plot(X)
obj <- mvn_mix(X, K=1:5, verbose=TRUE, crit=c("aic", "bic", "hqic"))
# Fit mixture models for 1 to 3 compoenents
obj <- mvn_mix(X, K=1:3, verbose=TRUE, crit=c("aic", "bic", "hqic"))
plot(1:5, obj$aic, type='o', col="orange")
lines(1:5, obj$bic, col="dodgerblue")
lines(1:5, obj$hqic, col="firebrick")
# Fit mixture models for 1 to 3 compoenents
obj <- mvn_mix(X, K=1:3, epsilon=c(1e-6, 1e-6, 1e-5), verbose=TRUE, crit=c("aic", "bic", "hqic"))
warnings()
K = c(1, 3, 5, 7)
k = 3
which(K == k)
obj
plot(1:3, obj$aic, type='l', col="orange")
lines(1:3, obj$bic, col="dodgerblue")
lines(1:3, obj$hqic, col="firebrick")
legend("bottomleft", c("aic", "bic", "hqic"), lwd=2, col=c("orange", "dodgerblue", "firebrick"))
# Fit mixture models for 1 to 3 compoenents
obj <- mvn_mix(X, K=1:3, epsilon=1e-3, verbose=TRUE, crit=c("aic", "bic", "hqic"))
plot(1:3, obj$aic, type='l', col="orange")
lines(1:3, obj$bic, col="dodgerblue")
lines(1:3, obj$hqic, col="firebrick")
document()
