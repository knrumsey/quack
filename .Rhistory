var(M2)
lam = rgamma(10000, 0.2, 1.4)
M = rpois(lam, lambda =lam)
lam = rgamma(10000, 2, 0.8)
M = rpois(lam, lambda =lam)
M2 = rnbinom(10000, 2, prob=0.8/1.8)
M
mean(M)
mean(M2)
var(M)
var(M2)
M2 = rnbinom(10000, 2.5, prob=0.8/1.8)
M2
mean(M2)
M2 = rnbinom(10000, 2, prob=0.8/1.8)
mean(M2)
p <- 100
p0 <- 48
eta <- abs(1e3*rt(p, 1))
eta
max(eta)
hist(eta)
eta <- abs(1e3*rt(p, 1))
eta
hist(eta)
make_weights(eta, p0)
#'
#' eta[1:3] <- 1e5
#' w <- make_weights(eta, p0)
#' sum(w)
#' w
#'
#' eta <- abs(1e3*rt(p, 3))
#' w <- make_weights(eta, p0)
#' sum(w)
#' w
make_weights <- function(eta, p0, alpha=2, epsilon=1, num_passes=3){
p <- length(eta)
v <- (eta^alpha + epsilon)/sum((eta^alpha + epsilon))*p0/p
delta <- 0
for(i in 1:num_passes){
beta <- mean((log(p0 + delta) - log(p))/log(v))
delta <- delta + p0 - sum(v^beta)
}
return(v^beta)
}
make_weights(eta, p0)
sum(make_weights(eta, p0))
which.max(eta)
eta[84] <- eta[84]*1e8
make_weights(eta, p0)
sum(make_weights(eta, p0))
eta[84]
(make_weights(eta, p0))[84]
expand.grid(1:n, 1:n)
n = 10
expand.grid(1:n, 1:n)
outer()
compute_sum <- function(x){
M <- length(x)
sum(outer(x[2:M], x[1:(M-1)], FUN=function(a, b) abs(a-b))[lower.tri(matrix(1:(M-1)^2, M-1, M-1), diag=TRUE)])
}
compute_sum(1:4)
compute_sum <- function(x){
M <- length(x)
sum(outer(x[2:M], x[1:(M-1)], FUN=function(a, b) abs(a-b))[lower.tri(matrix(1:(M-1)^2, M-1, M-1), diag=TRUE)])
}
compute_sum <- function(x){
M <- length(x)
sum(outer(x[2:M], x[1:(M-1)], FUN=function(a, b) abs(a-b))[lower.tri(matrix(1:(M-1)^2, M-1, M-1), diag=TRUE)])
}
compute_sum2 <- function(x){
M <- length(x)
res <- 0
for(i in 2:M){
for(j in 1:M){
res <- res + abs(x[i] - x[j])
}
}
return(res)
}
x <- 1:10
compute_sum(x)
compute_sum2(x)
M <- length(x)
sum(outer(x[2:M], x[1:(M-1)], FUN=function(a, b) abs(a-b))
)
outer(x[2:M], x[1:(M-1)], FUN=function(a, b) abs(a-b))
matrix(1:(M-1)^2, M-1, M-1)
lower.tri(matrix(1:(M-1)^2, M-1, M-1), diag=TRUE)
compute_sum2 <- function(x){
M <- length(x)
res <- 0
for(i in 2:M){
for(j in 1:i){
res <- res + abs(x[i] - x[j])
}
}
return(res)
}
x <- 1:10
compute_sum(x)
compute_sum2(x)
tic()
library(tictoc)
tic()
for(i in 1:100){
compute_sum(runif(1000))
}
toc()
tic()
for(i in 1:100){
compute_sum2(runif(1000))
}
toc()
idx <- unlist(lapply(2:M, function(i) 1:i))
idx
compute_sum3 <- function(x){
M <- length(x)
idx <- unlist(lapply(2:M, function(i) 1:i))
vals <- abs(x[rep(2:M, 2:M)] - x[idx])
return(sum(vals))
}
x= runif(1000)
compute_sum(x)
compute_sum2(x)
compute_sum3(x)
tic()
for(i in 1:100){
compute_sum3(runif(1000))
}
toc()
compute_sum <- function(x){
M <- length(x)
idx <- unlist(lapply(2:M, function(i) 1:i))
vals <- abs(x[rep(2:M, 2:M)] - x[idx])
return(sum(vals))
}
outer(x, x, function(a, b) abs(a-b))
sum(outer(x, x, function(a, b) abs(a-b)))
sum(outer(x, x, function(a, b) abs(a-b)))/M^2
compute_sum(x)/M/(M-1)
2*compute_sum(x)/M/(M-1)
2*compute_sum(x)/M^2
sum(outer(x, x, function(a, b) abs(a-b)))/M^2 == 2*compute_sum(x)/M^2
sum(outer(x, x, function(a, b) abs(a-b))) == 2*compute_sum(x)
compute_sum2 <- function(x){
sum(outer(x, x, function(a, b) abs(a-b)))
}
compute_sum <- function(x){
M <- length(x)
idx <- unlist(lapply(2:M, function(i) 1:i))
vals <- abs(x[rep(2:M, 2:M)] - x[idx])
return(2*sum(vals))
}
sum(outer(x, x, function(a, b) abs(a-b))) == compute_sum(x)
compute_sum2 <- function(x){
sum(outer(x, x, function(a, b) abs(a-b)))
}
tic()
for(i in 1:100){
compute_sum2(runif(1000))
}
toc()
compute_sum2 <- function(x){
sum(outer(x, x, function(a, b) abs(a-b)))
}
tic()
for(i in 1:100){
compute_sum2(runif(1000))
}
toc()
tic()
for(i in 1:100){
compute_sum(runif(1000))
}
toc()
tic()
for(i in 1:100){
compute_sum(runif(1000))
}
toc()
tic()
for(i in 1:100){
compute_sum2(runif(1000))
}
toc()
tic()
for(i in 1:100){
compute_sum(runif(100))
}
toc()
tic()
for(i in 1:100){
compute_sum2(runif(100))
}
toc()
tic()
for(i in 1:10){
compute_sum(runif(10000))
}
i
tic()
for(i in 1:5){
compute_sum(runif(10000))
}
toc()
tic()
for(i in 1:5){
compute_sum2(runif(10000))
}
toc()
tic()
for(i in 1:5){
compute_sum(runif(5000))
}
toc()
tic()
for(i in 1:5){
compute_sum2(runif(5000))
}
toc()
tic()
for(i in 1:5){
compute_sum(runif(6000))
}
toc()
tic()
for(i in 1:5){
compute_sum2(runif(6000))
}
toc()
tic()
for(i in 1:5){
compute_sum(runif(8000))
}
toc()
tic()
for(i in 1:5){
compute_sum2(runif(8000))
}
toc()
tic()
for(i in 1:5){
compute_sum(runif(7000))
}
toc()
tic()
for(i in 1:5){
compute_sum2(runif(7000))
}
toc()
tic()
for(i in 1:5){
compute_sum(runif(7000))
}
toc()
tic()
for(i in 1:5){
compute_sum2(runif(7000))
}
toc()
tic()
for(i in 1:5){
compute_sum(runif(6000))
}
toc()
tic()
for(i in 1:5){
compute_sum2(runif(6000))
}
toc()
tic()
for(i in 1:5){
compute_sum(runif(6500))
}
toc()
tic()
for(i in 1:5){
compute_sum2(runif(6500))
}
toc()
term2 <- 2*sum(abs(x[rep(2:M, 2:M)] - x[idx]))     # Faster for big M
term2
term2 <- sum(outer(x, x, function(a, b) abs(a-b))) # Fastest way for small M
term2
idx <- unlist(lapply(2:M, function(i) 1:i))
term2 <- 2*sum(abs(x[rep(2:M, 2:M)] - x[idx]))     # Faster for big M
term2
term2 <- sum(outer(x, x, function(a, b) abs(a-b))) # Fastest way for small M
term2
compute_sum1(x)
compute_sum1 <- function(x){
sum(outer(x, x, function(a, b) abs(a-b)))
}
compute_sum2 <- function(x){
M <- length(x)
idx <- unlist(lapply(2:M, function(i) 1:i))
vals <- abs(x[rep(2:M, 2:M)] - x[idx])
return(2*sum(vals))
}
compute_sum1(x)
compute_sum2(x)
x
sum(outer(x, x, function(a, b) abs(a-b)))
idx <- unlist(lapply(2:M, function(i) 1:i))
2*sum(abs(x[rep(2:M, 2:M)] - x[idx]))
compute_sum2(x)
M
M <- length(x)
idx <- unlist(lapply(2:M, function(i) 1:i))
term2 <- 2*sum(abs(x[rep(2:M, 2:M)] - x[idx]))     # Faster for big M
term2
sum(outer(x, x, function(a, b) abs(a-b)))
idx <- unlist(lapply(2:M, function(i) 1:i))
term2 <- 2*sum(abs(x[rep(2:M, 2:M)] - x[idx]))     # Faster for big M
term2
#' @param w parameter (between 0 and 1). Integral estimator <=> w=0 and Fair estimator <=> w=1 (See Zamo & Naveau 2017)
#' @references Zamo, M., & Naveau, P. (2018). Estimation of the continuous ranked probability score with limited information and applications to ensemble weather forecasts. Mathematical Geosciences, 50(2), 209-234.
#' @examples
#' y <- 0
#' x <- rnorm(100)
#' crps(x, y, w=1)
#' crps(x, y, w=0)
#' crps(x, y, w=0.5)
#'
#' @export
crps <- function(y, x, w=1){
M <- length(x)
term1 <- mean(abs(x-y))
if(M <= 6500){
term2 <- sum(outer(x, x, function(a, b) abs(a-b))) # Fastest way for small M
}else{
idx <- unlist(lapply(2:M, function(i) 1:i))
term2 <- 2*sum(abs(x[rep(2:M, 2:M)] - x[idx]))     # Faster for big M
}
res <- term1 + (1 - w/M)/(2*M*(M-1))*term2
}
document()
library(devtools)
document()
F1 <- function(x) pnorm(x)
I1 <- function(x, y=0) as.numeric(x >= y)
Q <- function(x, y) (F1(x) - I1(x, y))^2
integrate(Q, lower=-10, upper=10, y=0.1)
x <- rnorm(300)
crps(0.1, x)
print(crps(0.1, x))
?crps
#' @param w parameter (between 0 and 1). When w=0, the estimator is unbiased ("fair" and "PWM" from Zamo & Naveau 2017). When w=1, the estimator has lower variance ("INT" and "NRG" estimator from Zamo & Naveau 2017).
#' @references Zamo, M., & Naveau, P. (2018). Estimation of the continuous ranked probability score with limited information and applications to ensemble weather forecasts. Mathematical Geosciences, 50(2), 209-234.
#' @examples
#' y <- 0
#' x <- rnorm(100)
#' crps(x, y, w=1)
#' crps(x, y, w=0)
#' crps(x, y, w=0.5)
#'
#' @export
crps <- function(y, x, w=0){
M <- length(x)
term1 <- mean(abs(x-y))
if(M <= 6500){
term2 <- sum(outer(x, x, function(a, b) abs(a-b))) # Fastest way for small M
}else{
idx <- unlist(lapply(2:M, function(i) 1:i))
term2 <- 2*sum(abs(x[rep(2:M, 2:M)] - x[idx]))     # Faster for big M
}
res <- term1 + (1 - w/M)/(2*M*(M-1))*term2
}
#' @param w parameter (between 0 and 1). When w=0, the estimator is unbiased ("fair" and "PWM" from Zamo & Naveau 2017). When w=1, the estimator has lower variance ("INT" and "NRG" estimator from Zamo & Naveau 2017).
#' @references Zamo, M., & Naveau, P. (2018). Estimation of the continuous ranked probability score with limited information and applications to ensemble weather forecasts. Mathematical Geosciences, 50(2), 209-234.
#' @examples
#' y <- 0
#' x <- rnorm(100)
#' crps(x, y, w=1)
#' crps(x, y, w=0)
#' crps(x, y, w=0.5)
#'
#' @export
crps <- function(y, x, w=0){
M <- length(x)
term1 <- mean(abs(x-y))
if(M <= 6500){
term2 <- sum(outer(x, x, function(a, b) abs(a-b))) # Fastest way for small M
}else{
idx <- unlist(lapply(2:M, function(i) 1:i))
term2 <- 2*sum(abs(x[rep(2:M, 2:M)] - x[idx]))     # Faster for big M
}
res <- term1 + (1 - w/M)/(2*M*(M-1))*term2
}
curve(F1(x), from=-3, to=3)
curve(F1(x), from=-5, to=5)
curve(F1(x), from=-5, to=5, lwd=2)
curve(I1(x, 0.1), add=TRUE, col='red', lwd=2)
abline(v=0.1)
?integrate
curve(F1(x), from=-5, to=5, lwd=2)
curve(I1(x, 0.1), add=TRUE, col='red', lwd=2, n=1001)
curve(Q(x, 0.1), from=-5, to=5, lwd=2, col='blue')
par(mfrow=c(1,2))
par(mfrow=c(1,2))
x <- rnorm(300)
curve(F1(x), from=-5, to=5, lwd=2)
curve(I1(x, 0.1), add=TRUE, col='red', lwd=2, n=1001)
curve(Q(x, 0.1), from=-5, to=5, lwd=2, col='blue')
integrate(Q, lower=-10, upper=10, y=0.1)
curve(dexp(x)/2, add=TRUE)
curve(dexp(abs(x))/2, add=TRUE)
x <- rnorm(1000)
crps(0.1, x)
print(crps(0.1, x))
M <- length(x)
M
term1 <- mean(abs(x-y))
if(M <= 6500){
term2 <- sum(outer(x, x, function(a, b) abs(a-b))) # Fastest way for small M
}else{
idx <- unlist(lapply(2:M, function(i) 1:i))
term2 <- 2*sum(abs(x[rep(2:M, 2:M)] - x[idx]))     # Faster for big M
}
term2
term1
term1
term1 <- mean(abs(x-y))
y=0.1
term1 <- mean(abs(x-y))
term1
term2/(2*M*(M-1))
term1 + term2/(2*M*(M-1))
#' @param w parameter (between 0 and 1). When w=0, the estimator is unbiased ("fair" and "PWM" from Zamo & Naveau 2017). When w=1, the estimator has lower variance ("INT" and "NRG" estimator from Zamo & Naveau 2017).
#' @references Zamo, M., & Naveau, P. (2018). Estimation of the continuous ranked probability score with limited information and applications to ensemble weather forecasts. Mathematical Geosciences, 50(2), 209-234.
#' @examples
#' y <- 0
#' x <- rnorm(100)
#' crps(x, y, w=1)
#' crps(x, y, w=0)
#' crps(x, y, w=0.5)
#'
#' @export
crps <- function(y, x, w=0){
M <- length(x)
term1 <- mean(abs(x-y))
if(M <= 6500){
term2 <- sum(outer(x, x, function(a, b) abs(a-b))) # Fastest way for small M
}else{
idx <- unlist(lapply(2:M, function(i) 1:i))
term2 <- 2*sum(abs(x[rep(2:M, 2:M)] - x[idx]))     # Faster for big M
}
res <- term1 - (1 - w/M)*term2/(2*M*(M-1))
}
print(crps(0.1, x))
#' @param w parameter (between 0 and 1). When w=0, the estimator is unbiased ("fair" and "PWM" from Zamo & Naveau 2017). When w=1, the estimator has lower variance ("INT" and "NRG" estimator from Zamo & Naveau 2017).
#' @references Zamo, M., & Naveau, P. (2018). Estimation of the continuous ranked probability score with limited information and applications to ensemble weather forecasts. Mathematical Geosciences, 50(2), 209-234.
#' @examples
#' y <- 0
#' x <- rnorm(100)
#' crps(x, y, w=1)
#' crps(x, y, w=0)
#' crps(x, y, w=0.5)
#'
#' @export
crps <- function(y, x, w=0){
M <- length(x)
term1 <- mean(abs(x-y))
if(M <= 6500){
term2 <- sum(outer(x, x, function(a, b) abs(a-b))) # Fastest way for small M
}else{
idx <- unlist(lapply(2:M, function(i) 1:i))
term2 <- 2*sum(abs(x[rep(2:M, 2:M)] - x[idx]))     # Faster for big M
}
res <- term1 - (1 - w/M)*term2/(2*M*(M-1))
return(res)
}
crps(0.1, x)
integrate(Q, lower=-10, upper=10, y=0.1)
integrate(Q, lower=-10, upper=10, y=0.1)$value
F1 <- function(x) pnorm(x)
I1 <- function(x, y) as.numeric(x >= y)
Q <- function(x, y) (F1(x) - I1(x, y))^2
y <- 0.1
x <- rnorm(1000)
crps(y, x)
integrate(Q, lower=-10, upper=10, y=0.1)$value
x <- rnorm(100)
crps(y, x)
integrate(Q, lower=-10, upper=10, y=0.1)$value
document()
document()
?crps
F1 <- function(x) pnorm(x)
I1 <- function(x, y) as.numeric(x >= y)
Q <- function(x, y) (F1(x) - I1(x, y))^2
y <- 0.1
x <- rnorm(100)
integrate(Q, lower=-10, upper=10, y=y)$value
crps(y, x)
crps(y, x, w=0.5)
crps(y, x, w=0.1)
document()
?crps
F1 <- function(x) pnorm(x)
I1 <- function(x, y) as.numeric(x >= y)
Q <- function(x, y) (F1(x) - I1(x, y))^2
y <- 0.1
x <- rnorm(100)
integrate(Q, lower=-10, upper=10, y=y)$value
crps(y, x)
crps(y, x, w=0.5)
crps(y, x, w=1)
document()
library(quack)
