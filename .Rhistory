while(tmp == -Inf){
theta0 <- c(runif(3, -1, 1), -0.5, 4)
tmp <- lp(theta0, x, y)
}
plot(m)
plot(x, m)
m
beta1
beta2
beta1 = -0.5
beta2 = 4
m <- beta1 + beta2 * x^2
log(1/2)
image(R)
image(S)
lp <- function(theta, x, y){
kappa <- exp(theta[1])
nu    <- exp(theta[2])*0 + 1.2
phi   <- exp(theta[3])
beta1 <- theta[4]
beta2 <- theta[5]
m <- beta1 + beta2 * x^2
S <- makeR(x, kappa, nu, phi)
res <- dmvnorm(y, m, S, log=TRUE)
res <- res + sum(dt(c(kappa, phi)/100, 5, log=TRUE))
res <- res + sum(dnorm(c(beta1, beta2), 0, 100, log=TRUE))
return(res)
}
tmp <- -Inf
while(tmp == -Inf){
theta0 <- c(runif(3, -1, 1), -0.5, 4)
tmp <- lp(theta0, x, y)
}
kappa <- exp(theta[1])
nu    <- exp(theta[2])*0 + 1.2
phi   <- exp(theta[3])
beta1 <- theta[4]
beta2 <- theta[5]
m <- beta1 + beta2 * x^2
S <- makeR(x, kappa, nu, phi)
S
image(S)
S
h
makeR <- function(x1, kappa, nu, phi, x2=NULL,tau=1e-7){
if(is.null(x2)){
x2 <- x1
}
R <- matrix(1, nrow=length(x1), ncol=length(x2))
for(ii in 1:length(x1)){
for(jj in 1:length(x2)){
h <- sqrt(sum((x1[ii] - x2[ii])^2))
R[ii,jj] <- matern.covariance(h, kappa, nu, phi) + tau^2
}
}
return(R)
}
lp <- function(theta, x, y){
kappa <- exp(theta[1])
nu    <- exp(theta[2])
phi   <- exp(theta[3])
beta1 <- theta[4]
beta2 <- theta[5]
m <- beta1 + beta2 * x^2
S <- makeR(x, kappa, nu, phi)
res <- dmvnorm(y, m, S, log=TRUE)
res <- res + sum(dt(c(kappa, phi)/100, 5, log=TRUE))
res <- res + sum(dnorm(c(beta1, beta2), 0, 100, log=TRUE))
return(res)
}
tmp <- -Inf
while(tmp == -Inf){
theta0 <- c(runif(3, -1, 1), -0.5, 4)
tmp <- lp(theta0, x, y)
}
tmp
library(rSPDE)
library(MHadaptive)
library(mvtnorm)
#Simulate data
ff <- function(x){
x <- 0.5 + 2*x
sin(10*pi*x)/(2*x) + (x-1)^4
#x*sin(x*10)
}
n <- 100
x <- seq(0, 1, length.out=n)
y <- ff(x)
curve(ff(x), n=1001)
points(x, y, pch=16, col='orange', cex=1.5)
# 2. Write log posterior
#' theta has components
#' kappa = range parameter l = sqrt(1/kappa) is the length-scale
#' nu    = smoothness parameter
#' phi   = marginal spatial scale (phi^2 is variance; phi called sigma in rSPDE::matern.covariance function)
makeR <- function(x1, kappa, nu, phi, x2=NULL,tau=1e-7){
if(is.null(x2)){
x2 <- x1
}
R <- matrix(1, nrow=length(x1), ncol=length(x2))
for(ii in 1:length(x1)){
for(jj in 1:length(x2)){
h <- sqrt(sum((x1[ii] - x2[ii])^2))
R[ii,jj] <- matern.covariance(h, kappa, nu, phi) + tau^2
}
}
return(R)
}
lp <- function(theta, x, y){
kappa <- exp(theta[1])
nu    <- exp(theta[2])
phi   <- exp(theta[3])
beta1 <- theta[4]
beta2 <- theta[5]
m <- beta1 + beta2 * x^2
S <- makeR(x, kappa, nu, phi)
res <- dmvnorm(y, m, S, log=TRUE)
res <- res + sum(dt(c(kappa, phi)/100, 5, log=TRUE))
res <- res + sum(dnorm(c(beta1, beta2), 0, 100, log=TRUE))
return(res)
}
tmp <- -Inf
while(tmp == -Inf){
theta0 <- c(runif(3, -1, 1), -0.5, 4)
tmp <- lp(theta0, x, y)
}
S
kappa <- exp(theta[1])
nu    <- exp(theta[2])
phi   <- exp(theta[3])
beta1 <- theta[4]
beta2 <- theta[5]
m <- beta1 + beta2 * x^2
S <- makeR(x, kappa, nu, phi)
S
image(S)
makeR <- function(x1, kappa, nu, phi, x2=NULL,tau=1e-7){
if(is.null(x2)){
x2 <- x1
}
R <- matrix(1, nrow=length(x1), ncol=length(x2))
for(ii in 1:length(x1)){
for(jj in 1:length(x2)){
h <- sqrt(sum((x1[ii] - x2[jj])^2))
R[ii,jj] <- matern.covariance(h, kappa, nu, phi) + tau^2
}
}
return(R)
}
lp <- function(theta, x, y){
kappa <- exp(theta[1])
nu    <- exp(theta[2])
phi   <- exp(theta[3])
beta1 <- theta[4]
beta2 <- theta[5]
m <- beta1 + beta2 * x^2
S <- makeR(x, kappa, nu, phi)
res <- dmvnorm(y, m, S, log=TRUE)
res <- res + sum(dt(c(kappa, phi)/100, 5, log=TRUE))
res <- res + sum(dnorm(c(beta1, beta2), 0, 100, log=TRUE))
return(res)
}
tmp <- -Inf
while(tmp == -Inf){
theta0 <- c(runif(3, -1, 1), -0.5, 4)
tmp <- lp(theta0, x, y)
}
tmp
theta0 <- c(runif(3, -1, 1), -0.5, 4)
tmp <- lp(theta0, x, y)
tmp
theta0 <- c(0, 0, 0, -0.5, 4)
tmp <- lp(theta0, x, y)
tmp
fit <- Metro_Hastings(lp, theta0)
fit <- Metro_Hastings(lp, theta0m, x=x, y=y)
fit <- Metro_Hastings(lp, theta0, x=x, y=y)
fit <- Metro_Hastings(lp, theta0, x=x, y=y, iterations = 1000)
?lp
?Metro_Hastings
for(i in 1:1000) lp(theta0, x, y)
for(i in 1:4) lp(theta0, x, y)
lp(theta0, x, y)
for(i in 1:4) lp(theta0, x, y)
n <- 20
x <- seq(0, 1, length.out=n)
y <- ff(x)
curve(ff(x), n=1001)
points(x, y, pch=16, col='orange', cex=1.5)
makeR <- function(x1, kappa, nu, phi, x2=NULL,tau=1e-7){
if(is.null(x2)){
x2 <- x1
}
R <- matrix(1, nrow=length(x1), ncol=length(x2))
for(ii in 1:length(x1)){
for(jj in 1:length(x2)){
h <- sqrt(sum((x1[ii] - x2[jj])^2))
R[ii,jj] <- matern.covariance(h, kappa, nu, phi) + tau^2
}
}
return(R)
}
lp <- function(theta, x, y){
kappa <- exp(theta[1])
nu    <- exp(theta[2])
phi   <- exp(theta[3])
beta1 <- theta[4]
beta2 <- theta[5]
m <- beta1 + beta2 * x^2
S <- makeR(x, kappa, nu, phi)
res <- dmvnorm(y, m, S, log=TRUE)
res <- res + sum(dt(c(kappa, phi)/100, 5, log=TRUE))
res <- res + sum(dnorm(c(beta1, beta2), 0, 100, log=TRUE))
return(res)
}
theta0 <- c(0, 0, 0, -0.5, 4)
fit <- Metro_Hastings(lp, theta0, x=x, y=y)
ts,plot(fi$trace[,1])
ts,plot(fi$trace[,1])ts.plot(fit$trace[,1])
ts.plot(fit$trace[,1])
thetap <- fit$trace
kappa <- exp(thetap[,1])
nu    <- exp(thetap[,2])
phi   <- exp(thetap[,3])
phi
lambda <- phi^2*kappa^(2*nu)
ts.plot(lambda)
kappa <- exp(thetap[,1])
nu    <- exp(thetap[,2])
phi   <- exp(thetap[,3])
lambda <- phi^2*kappa^(2*nu)
ts.plot(lambda)
hist(lambda)
hist(lambda, breaks=50)
res <- 0
tmp <- 0
for(i in 0:1000){
tmp <- tmp + dpois(i, m*lambda)
}
m <- 1000
lambda <- 1
res <- 0
tmp <- 0
for(i in 0:1000){
tmp <- tmp + dpois(i, m*lambda)
}
tmp
for(i in 0:2000){
tmp <- tmp + dpois(i, m*lambda)
}
tmp
m <- 1000
lambda <- 1
res <- 0
tmp <- 0
for(i in 0:2000){
tmp <- tmp + dpois(i, m*lambda)
}
tmp
dbinom(0, 1, .4)
dbinom(0, 0, .4)
dbinom(1, 0, .4)
dbinom(5, 0, .4)
z <- 5
res <- 0
tmp <- 0
for(i in 0:2000){
tmp <- tmp + dpois(i, m*lambda)
res <- res + z*dpois(i, m*lambda)*dbinom(z, i, 1/m)/i
}
res
res
for(i in 1:2000){
tmp <- tmp + dpois(i, m*lambda)
res <- res + z*dpois(i, m*lambda)*dbinom(z, i, 1/m)/i
}
m <- 1000
lambda <- 1
z <- 5
res <- 0
tmp <- 0
for(i in 1:2000){
tmp <- tmp + dpois(i, m*lambda)
res <- res + z*dpois(i, m*lambda)*dbinom(z, i, 1/m)/i
}
res
dpois(5, 1)
m <- 1000
lambda <- 1
z <- 5
res <- 0
tmp <- 0
for(i in 1:3000){
tmp <- tmp + dpois(i, m*lambda)
res <- res + z*dpois(i, m*lambda)*dbinom(z, i, 1/m)/i
}
res
185-(299*3)/1000
1185-(299*3)
library(devtools)
library(roxygen2)
document()
library(plyr)
?ggsummary
df <- data.frame(foo = sample(c("a", "b", "c"), 100),
fie = rpois(100, 0.5))
df$y <- rnorm(100, df$fie + 1, 0.1)*(df$foo == "a") +
rnorm(100, df$fie + 2, 0.1)*(df$foo == "b") +
rnorm(100, df$fie + 3, 0.1)*(df$foo == "c")
ggsummary(df, measurevar = "y", groupvars = c("foo", "fie"))
df <- data.frame(foo = sample(c("a", "b", "c"), 100, replace=TRUE),
fie = rpois(100, 0.5))
df$y <- rnorm(100, df$fie + 1, 0.1)*(df$foo == "a") +
rnorm(100, df$fie + 2, 0.1)*(df$foo == "b") +
rnorm(100, df$fie + 3, 0.1)*(df$foo == "c")
ggsummary(df, measurevar = "y", groupvars = c("foo", "fie"))
set.seed(111);df <- data.frame(foo = sample(c("a", "b", "c"), 100, replace=TRUE),
fie = rpois(100, 0.5))
df$y <- rnorm(100, df$fie + 1, 0.1)*(df$foo == "a") +
rnorm(100, df$fie + 2, 0.1)*(df$foo == "b") +
rnorm(100, df$fie + 3, 0.1)*(df$foo == "c")
ggsummary(df, measurevar = "y", groupvars = c("foo", "fie"))
library(tidyverse)
ggplot(summ, x=fie, y=y, fill=foo)
set.seed(111);df <- data.frame(foo = sample(c("a", "b", "c"), 100, replace=TRUE),
fie = rpois(100, 0.5))
df$y <- rnorm(100, df$fie + 1, 0.1)*(df$foo == "a") +
rnorm(100, df$fie + 2, 0.1)*(df$foo == "b") +
rnorm(100, df$fie + 3, 0.1)*(df$foo == "c")
summ <- ggsummary(df, measurevar = "y", groupvars = c("foo", "fie"))
df
summ
set.seed(111);df <- data.frame(foo = sample(c("a", "b", "c"), 100, replace=TRUE),
fie = rpois(100, 0.5))
df$y <- rnorm(100, df$fie + 1, 0.1)*(df$foo == "a") +
rnorm(100, df$fie + 2, 0.1)*(df$foo == "b") +
rnorm(100, df$fie + 3, 0.1)*(df$foo == "c")
summ <- ggsummary(df, measurevar = "y", groupvars = c("foo", "fie"))
set.seed(111);df <- data.frame(foo = sample(c("a", "b", "c"), 100, replace=TRUE),
fie = rpois(100, 0.5))
df$y <- rnorm(100, df$fie + 1, 0.1)*(df$foo == "a") +
rnorm(100, df$fie + 2, 0.1)*(df$foo == "b") +
rnorm(100, df$fie + 3, 0.1)*(df$foo == "c")
ggsummary(df, measurevar = "y", groupvars = c("foo", "fie"))
df
df$y
ggsummary(df, measurevar="y")
set.seed(111);df <- data.frame(foo = sample(c("a", "b", "c"), 100, replace=TRUE),
fie = rpois(100, 0.5))
df$y <- rnorm(100, df$fie + 1, 0.1)*(df$foo == "a") +
rnorm(100, df$fie + 2, 0.1)*(df$foo == "b") +
rnorm(100, df$fie + 3, 0.1)*(df$foo == "c")
ggsummary(df, measurevar = "y", groupvars = c("foo", "fie"))
set.seed(111)
df <- data.frame(foo = sample(c("a", "b", "c"), 100),
fie = rpois(100, 0.5))
set.seed(111);df <- data.frame(foo = sample(c("a", "b", "c"), 100, replace=TRUE),
fie = rpois(100, 0.5))
df$y <- rnorm(100, df$fie + 1, 0.1)*(df$foo == "a") +
rnorm(100, df$fie + 2, 0.1)*(df$foo == "b") +
rnorm(100, df$fie + 3, 0.1)*(df$foo == "c")
ggsummary(df, measurevar = "y", groupvars = c("foo", "fie"))
df <- data.frame(foo = sample(c("a", "b", "c"), 100),
fie = rpois(100, 0.5), replace=TRUE)
df <- data.frame(foo = sample(c("a", "b", "c"), 100, replace=TRUE),
fie = rpois(100, 0.5))
df
df$y <- rnorm(100, df$fie + 1, 0.1)*(df$foo == "a") +
rnorm(100, df$fie + 2, 0.1)*(df$foo == "b") +
rnorm(100, df$fie + 3, 0.1)*(df$foo == "c")
df
names(df)
ggsummary(df, measurevar = "y", groupvars = c("foo", "fie"))
library(plyr)
ggsummary(df, measurevar = "y", groupvars = c("foo", "fie"))
measurevar="y"
groupvars=c("foo", "fie")
# New version of length which can handle NA's: if na.rm==T, don't count them
length2 <- function (x, na.rm=FALSE) {
if (na.rm) sum(!is.na(x))
else       length(x)
}
# This does the summary. For each group's data frame, return a vector with
# N, mean, and sd
datac <- plyr::ddply(data, groupvars, .drop=.drop,
.fun = function(xx, col) {
c(N    = length2(xx[[col]], na.rm=na.rm),
mean = mean   (xx[[col]], na.rm=na.rm),
sd   = sd     (xx[[col]], na.rm=na.rm)
)
},
measurevar
)
# This does the summary. For each group's data frame, return a vector with
# N, mean, and sd
datac <- plyr::ddply(data, groupvars, .drop=.drop,
.fun = function(xx, col) {
c(N    = length2(xx[[col]], na.rm=na.rm),
mean = mean   (xx[[col]], na.rm=na.rm),
sd   = sd     (xx[[col]], na.rm=na.rm)
)
},
measurevar
)
table(df$foo, df$fie)
set.seed(111);df <- data.frame(foo = sample(c("a", "b", "c"), 100, replace=TRUE),
fie = rpois(100, 0.5))
df$y <- rnorm(100, df$fie + 1, 0.1)*(df$foo == "a") +
rnorm(100, df$fie + 2, 0.1)*(df$foo == "b") +
rnorm(100, df$fie + 3, 0.1)*(df$foo == "c")
ggsummary(df, measurevar = "y", groupvars = c("foo", "fie"))
set.seed(1111);df <- data.frame(foo = sample(c("a", "b", "c"), 100, replace=TRUE),
fie = rpois(100, 0.5))
df$y <- rnorm(100, df$fie + 1, 0.1)*(df$foo == "a") +
rnorm(100, df$fie + 2, 0.1)*(df$foo == "b") +
rnorm(100, df$fie + 3, 0.1)*(df$foo == "c")
ggsummary(df, measurevar = "y", groupvars = c("foo", "fie"))
set.seed(11111);df <- data.frame(foo = sample(c("a", "b", "c"), 100, replace=TRUE),
fie = rpois(100, 0.5))
df$y <- rnorm(100, df$fie + 1, 0.1)*(df$foo == "a") +
rnorm(100, df$fie + 2, 0.1)*(df$foo == "b") +
rnorm(100, df$fie + 3, 0.1)*(df$foo == "c")
ggsummary(df, measurevar = "y", groupvars = c("foo", "fie"))
last_error()
rlang
library(rlang)
last_error()
#' df <- data.frame(foo = sample(c("a", "b", "c"), 100, replace=TRUE),
#'                  fie = rpois(100, 0.5))
#' df$y <- rnorm(100, df$fie + 1, 0.1)*(df$foo == "a") +
#'         rnorm(100, df$fie + 2, 0.1)*(df$foo == "b") +
#'         rnorm(100, df$fie + 3, 0.1)*(df$foo == "c")
#'
#' summ <- ggsummary(df, measurevar = "y", groupvars = c("foo", "fie"))
#' #ggplot2
#'
#' @export
ggsummary <- function(data=NULL, measurevar, groupvars=NULL, na.rm=FALSE,
conf.interval=.95, .drop=TRUE) {
# New version of length which can handle NA's: if na.rm==T, don't count them
length2 <- function (x, na.rm=FALSE) {
if (na.rm) sum(!is.na(x))
else       length(x)
}
# This does the summary. For each group's data frame, return a vector with
# N, mean, and sd
datac <- plyr::ddply(data, groupvars, .drop=.drop,
.fun = function(xx, col) {
c(N    = length2(xx[[col]], na.rm=na.rm),
mean = mean   (xx[[col]], na.rm=na.rm),
sd   = sd     (xx[[col]], na.rm=na.rm)
)
},
measurevar
)
# Rename the "mean" column
#datac <- rename(datac, c("mean" = measurevar))
datac$se <- datac$sd / sqrt(datac$N)  # Calculate standard error of the mean
# Confidence interval multiplier for standard error
# Calculate t-statistic for confidence interval:
# e.g., if conf.interval is .95, use .975 (above/below), and use df=N-1
ciMult <- qt(conf.interval/2 + .5, datac$N-1)
datac$ci <- datac$se * ciMult
return(datac)
}
document()
set.seed(111)
?ggsummary
set.seed(111)
df <- data.frame(foo = sample(c("a", "b", "c"), 100, replace=TRUE),
fie = rpois(100, 0.5))
df$y <- rnorm(100, df$fie + 1, 0.1)*(df$foo == "a") +
rnorm(100, df$fie + 2, 0.1)*(df$foo == "b") +
rnorm(100, df$fie + 3, 0.1)*(df$foo == "c")
summ <- ggsummary(df, measurevar = "y", groupvars = c("foo", "fie"))
summ
ggplot(summ1, aes(x=fie, y=y, fill=foo)) +
geom_bar(position=position_dodge2(padding=0.1), stat="identity") +
geom_errorbar(aes(ymin=y-ci, ymax=y+ci),
width=.05,                    # Width of the error bars
position=position_dodge(.45)) +
title("hello")
ggplot(summ, aes(x=fie, y=y, fill=foo)) +
geom_bar(position=position_dodge2(padding=0.1), stat="identity") +
geom_errorbar(aes(ymin=y-ci, ymax=y+ci),
width=.05,                    # Width of the error bars
position=position_dodge(.45))
summ <- ggsummary(df, measurevar = "y", groupvars = c("foo", "fie"))
summ
ggplot(summ1, aes(x=fie, y=mean, fill=foo)) +
geom_bar(position=position_dodge2(padding=0.1), stat="identity") +
geom_errorbar(aes(ymin=mean-ci, ymax=mean+ci),
width=.05,                    # Width of the error bars
position=position_dodge(.45)) +
title("dslsj)")
ggplot(summ, aes(x=fie, y=mean, fill=foo)) +
geom_bar(position=position_dodge2(padding=0.1), stat="identity") +
geom_errorbar(aes(ymin=mean-ci, ymax=mean+ci),
width=.05,                    # Width of the error bars
position=position_dodge(.45))
ggplot(summ, aes(x=fie, y=mean, fill=foo)) +
geom_errorbar(aes(ymin=mean-ci, ymax=mean+ci))
ggplot(summ, aes(x=fie, y=mean, fill=foo)) +
geom_bar(position=position_dodge2(padding=0.1), stat="identity") +
geom_errorbar(aes(ymin=mean-ci, ymax=mean+ci),
width=.05,                    # Width of the error bars
position=position_dodge(.9))
document()
?ggsumm
?ggsummary
summ
document()
