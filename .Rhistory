curve(-1.10 + .4775*10^(x), add=T)
curve(I(log(y))~x)
curve(I(log(y))~x)
I(log(y))
library(MHadaptive)
#Simulate data
ff <- function(x){
x <- 0.5 + 2*x
sin(10*pi*x)/(2*x) + (x-1)^4
#x*sin(x*10)
}
n <- 100
x <- seq(0, 1, length.out=n)
y <- ff(x)
curve(ff(x), n=1001)
points(x, y, pch=16, col='orange', cex=1.5)
?variogram
variogram(y~z)
variogram(y~x)
data <- data.frame(x=x, y=y)
variogram(y~x, data=data)
data(meuse)
meuse
dim(muese)
dim(meuse)
tmp <- 1/rexp(1000, 2)
mean(tmp)
mean(tmp[which(tmp < 10)])
tmp <- 1/rexp(1000, 1)
mean(tmp[which(tmp < 10)])
?Matern
?matern.cov
fields::matern.image.cov
?fields::matern.image.cov
?matern.cov
matern.cov
?fields::Matern
dist
?dist
dist(x, x)
dist(x)
class(dist(x))
?matern.image.cov
besselK()
besselK
install.packages("matern.cov")
library(rSPDE)
install.packages('rSPDE')
library(rSPDE)
?rSPDE::matern.covariance
dist(x)
?dist
?matern.covariance
library(matern.covariance)
library(rSPDE)
library(MHadaptive)
lm(y ~ x + I(x^2))
curve(0.5, -5*x + 8*x^2, add=T, col='red')
curve(0.5 -5*x + 8*x^2, add=T, col='red')
lm(y ~ I(x^2))
curve(-.5 + 4*x^2, add=T)
4^2 - 1^2
sqrt(4^2 - 1^2)
sum((4-1)^2)
makeR <- function(x1, x2=NULL, kappa, nu, phi, tau=1e-7){
if(is.null(x2)){
x2 <- x1
}
R <- matrix(1, nrow=length(x1), ncol=length(x2))
for(ii in 1:length(x1)){
for(jj in 1:length(x2)){
h <- sqrt(sum((x1 - x2)^2))
R[i,j] <- matern.covariance(h, kappa, nu, phi) + tau^2
}
}
}
makeR <- function(x1, x2=NULL, kappa, nu, phi, tau=1e-7){
if(is.null(x2)){
x2 <- x1
}
R <- matrix(1, nrow=length(x1), ncol=length(x2))
for(ii in 1:length(x1)){
for(jj in 1:length(x2)){
h <- sqrt(sum((x1 - x2)^2))
R[i,j] <- matern.covariance(h, kappa, nu, phi) + tau^2
}
}
}
lp <- function(theta, x, y){
kappa <- exp(theta[1])
nu    <- exp(theta[2])
phi   <- exp(theta[3])
beta1 <- theta[4]
beta2 <- theta[5]
m <- beta1 + beta2 * x^2
S <- makeR(x, kappa, nu, phi)
res <- dmvnorm(y, m, S, log=TRUE)
res <- res + sum(dt(c(kappa, phi)/100, 5, log=TRUE))
res <- res + sum(dnorm(c(beta1, beta2), 0, 100, log=TRUE))
return(res)
}
res
lp <- function(theta, x, y){
kappa <- exp(theta[1])
nu    <- exp(theta[2])
phi   <- exp(theta[3])
beta1 <- theta[4]
beta2 <- theta[5]
m <- beta1 + beta2 * x^2
S <- makeR(x, kappa, nu, phi)
res <- dmvnorm(y, m, S, log=TRUE)
res <- res + sum(dt(c(kappa, phi)/100, 5, log=TRUE))
res <- res + sum(dnorm(c(beta1, beta2), 0, 100, log=TRUE))
return(res)
}
theta0 <- rep(0, 5)
lp(theta0, x, y)
makeR <- function(x1, kappa, nu, phi, x2=NULL,tau=1e-7){
if(is.null(x2)){
x2 <- x1
}
R <- matrix(1, nrow=length(x1), ncol=length(x2))
for(ii in 1:length(x1)){
for(jj in 1:length(x2)){
h <- sqrt(sum((x1 - x2)^2))
R[i,j] <- matern.covariance(h, kappa, nu, phi) + tau^2
}
}
}
lp <- function(theta, x, y){
kappa <- exp(theta[1])
nu    <- exp(theta[2])
phi   <- exp(theta[3])
beta1 <- theta[4]
beta2 <- theta[5]
m <- beta1 + beta2 * x^2
S <- makeR(x, kappa, nu, phi)
res <- dmvnorm(y, m, S, log=TRUE)
res <- res + sum(dt(c(kappa, phi)/100, 5, log=TRUE))
res <- res + sum(dnorm(c(beta1, beta2), 0, 100, log=TRUE))
return(res)
}
theta0 <- rep(0, 5)
lp(theta0, x, y)
makeR <- function(x1, kappa, nu, phi, x2=NULL,tau=1e-7){
if(is.null(x2)){
x2 <- x1
}
R <- matrix(1, nrow=length(x1), ncol=length(x2))
for(ii in 1:length(x1)){
for(jj in 1:length(x2)){
h <- sqrt(sum((x1 - x2)^2))
R[ii,jj] <- matern.covariance(h, kappa, nu, phi) + tau^2
}
}
}
lp(theta0, x, y)
library(mvtnorm)
lp(theta0, x, y)
theta <- theta0
kappa <- exp(theta[1])
nu    <- exp(theta[2])
phi   <- exp(theta[3])
beta1 <- theta[4]
beta2 <- theta[5]
m <- beta1 + beta2 * x^2
length(m)
S <- makeR(x, kappa, nu, phi)
dim(S)
S
S <- makeR(x, kappa, nu, phi)
S
kappa
x1 = x
if(is.null(x2)){
x2 <- x1
}
x2 = NULL
if(is.null(x2)){
x2 <- x1
}
R <- matrix(1, nrow=length(x1), ncol=length(x2))
for(ii in 1:length(x1)){
for(jj in 1:length(x2)){
h <- sqrt(sum((x1 - x2)^2))
R[ii,jj] <- matern.covariance(h, kappa, nu, phi) + tau^2
}
}
R
makeR <- function(x1, kappa, nu, phi, x2=NULL,tau=1e-7){
if(is.null(x2)){
x2 <- x1
}
R <- matrix(1, nrow=length(x1), ncol=length(x2))
for(ii in 1:length(x1)){
for(jj in 1:length(x2)){
h <- sqrt(sum((x1 - x2)^2))
R[ii,jj] <- matern.covariance(h, kappa, nu, phi) + tau^2
}
}
return(R)
}
lp(theta0, x, y)
theta0 <- c(0, 0, 0, -0.5, 4)
lp(theta0, x, y)
theta0 <- c(runif(3, -1, 1), -0.5, 4)
lp(theta0, x, y)
theta0 <- c(runif(3, -1, 1), -0.5, 4)
lp(theta0, x, y)
tmp == -Inf
-Inf == -Inf
tmp <- -Inf
tmp <- -Inf
while(tmp == -Inf){
theta0 <- c(runif(3, -1, 1), -0.5, 4)
tmp <- lp(theta0, x, y)
}
plot(m)
plot(x, m)
m
beta1
beta2
beta1 = -0.5
beta2 = 4
m <- beta1 + beta2 * x^2
log(1/2)
image(R)
image(S)
lp <- function(theta, x, y){
kappa <- exp(theta[1])
nu    <- exp(theta[2])*0 + 1.2
phi   <- exp(theta[3])
beta1 <- theta[4]
beta2 <- theta[5]
m <- beta1 + beta2 * x^2
S <- makeR(x, kappa, nu, phi)
res <- dmvnorm(y, m, S, log=TRUE)
res <- res + sum(dt(c(kappa, phi)/100, 5, log=TRUE))
res <- res + sum(dnorm(c(beta1, beta2), 0, 100, log=TRUE))
return(res)
}
tmp <- -Inf
while(tmp == -Inf){
theta0 <- c(runif(3, -1, 1), -0.5, 4)
tmp <- lp(theta0, x, y)
}
kappa <- exp(theta[1])
nu    <- exp(theta[2])*0 + 1.2
phi   <- exp(theta[3])
beta1 <- theta[4]
beta2 <- theta[5]
m <- beta1 + beta2 * x^2
S <- makeR(x, kappa, nu, phi)
S
image(S)
S
h
makeR <- function(x1, kappa, nu, phi, x2=NULL,tau=1e-7){
if(is.null(x2)){
x2 <- x1
}
R <- matrix(1, nrow=length(x1), ncol=length(x2))
for(ii in 1:length(x1)){
for(jj in 1:length(x2)){
h <- sqrt(sum((x1[ii] - x2[ii])^2))
R[ii,jj] <- matern.covariance(h, kappa, nu, phi) + tau^2
}
}
return(R)
}
lp <- function(theta, x, y){
kappa <- exp(theta[1])
nu    <- exp(theta[2])
phi   <- exp(theta[3])
beta1 <- theta[4]
beta2 <- theta[5]
m <- beta1 + beta2 * x^2
S <- makeR(x, kappa, nu, phi)
res <- dmvnorm(y, m, S, log=TRUE)
res <- res + sum(dt(c(kappa, phi)/100, 5, log=TRUE))
res <- res + sum(dnorm(c(beta1, beta2), 0, 100, log=TRUE))
return(res)
}
tmp <- -Inf
while(tmp == -Inf){
theta0 <- c(runif(3, -1, 1), -0.5, 4)
tmp <- lp(theta0, x, y)
}
tmp
library(rSPDE)
library(MHadaptive)
library(mvtnorm)
#Simulate data
ff <- function(x){
x <- 0.5 + 2*x
sin(10*pi*x)/(2*x) + (x-1)^4
#x*sin(x*10)
}
n <- 100
x <- seq(0, 1, length.out=n)
y <- ff(x)
curve(ff(x), n=1001)
points(x, y, pch=16, col='orange', cex=1.5)
# 2. Write log posterior
#' theta has components
#' kappa = range parameter l = sqrt(1/kappa) is the length-scale
#' nu    = smoothness parameter
#' phi   = marginal spatial scale (phi^2 is variance; phi called sigma in rSPDE::matern.covariance function)
makeR <- function(x1, kappa, nu, phi, x2=NULL,tau=1e-7){
if(is.null(x2)){
x2 <- x1
}
R <- matrix(1, nrow=length(x1), ncol=length(x2))
for(ii in 1:length(x1)){
for(jj in 1:length(x2)){
h <- sqrt(sum((x1[ii] - x2[ii])^2))
R[ii,jj] <- matern.covariance(h, kappa, nu, phi) + tau^2
}
}
return(R)
}
lp <- function(theta, x, y){
kappa <- exp(theta[1])
nu    <- exp(theta[2])
phi   <- exp(theta[3])
beta1 <- theta[4]
beta2 <- theta[5]
m <- beta1 + beta2 * x^2
S <- makeR(x, kappa, nu, phi)
res <- dmvnorm(y, m, S, log=TRUE)
res <- res + sum(dt(c(kappa, phi)/100, 5, log=TRUE))
res <- res + sum(dnorm(c(beta1, beta2), 0, 100, log=TRUE))
return(res)
}
tmp <- -Inf
while(tmp == -Inf){
theta0 <- c(runif(3, -1, 1), -0.5, 4)
tmp <- lp(theta0, x, y)
}
S
kappa <- exp(theta[1])
nu    <- exp(theta[2])
phi   <- exp(theta[3])
beta1 <- theta[4]
beta2 <- theta[5]
m <- beta1 + beta2 * x^2
S <- makeR(x, kappa, nu, phi)
S
image(S)
makeR <- function(x1, kappa, nu, phi, x2=NULL,tau=1e-7){
if(is.null(x2)){
x2 <- x1
}
R <- matrix(1, nrow=length(x1), ncol=length(x2))
for(ii in 1:length(x1)){
for(jj in 1:length(x2)){
h <- sqrt(sum((x1[ii] - x2[jj])^2))
R[ii,jj] <- matern.covariance(h, kappa, nu, phi) + tau^2
}
}
return(R)
}
lp <- function(theta, x, y){
kappa <- exp(theta[1])
nu    <- exp(theta[2])
phi   <- exp(theta[3])
beta1 <- theta[4]
beta2 <- theta[5]
m <- beta1 + beta2 * x^2
S <- makeR(x, kappa, nu, phi)
res <- dmvnorm(y, m, S, log=TRUE)
res <- res + sum(dt(c(kappa, phi)/100, 5, log=TRUE))
res <- res + sum(dnorm(c(beta1, beta2), 0, 100, log=TRUE))
return(res)
}
tmp <- -Inf
while(tmp == -Inf){
theta0 <- c(runif(3, -1, 1), -0.5, 4)
tmp <- lp(theta0, x, y)
}
tmp
theta0 <- c(runif(3, -1, 1), -0.5, 4)
tmp <- lp(theta0, x, y)
tmp
theta0 <- c(0, 0, 0, -0.5, 4)
tmp <- lp(theta0, x, y)
tmp
fit <- Metro_Hastings(lp, theta0)
fit <- Metro_Hastings(lp, theta0m, x=x, y=y)
fit <- Metro_Hastings(lp, theta0, x=x, y=y)
fit <- Metro_Hastings(lp, theta0, x=x, y=y, iterations = 1000)
?lp
?Metro_Hastings
for(i in 1:1000) lp(theta0, x, y)
for(i in 1:4) lp(theta0, x, y)
lp(theta0, x, y)
for(i in 1:4) lp(theta0, x, y)
n <- 20
x <- seq(0, 1, length.out=n)
y <- ff(x)
curve(ff(x), n=1001)
points(x, y, pch=16, col='orange', cex=1.5)
makeR <- function(x1, kappa, nu, phi, x2=NULL,tau=1e-7){
if(is.null(x2)){
x2 <- x1
}
R <- matrix(1, nrow=length(x1), ncol=length(x2))
for(ii in 1:length(x1)){
for(jj in 1:length(x2)){
h <- sqrt(sum((x1[ii] - x2[jj])^2))
R[ii,jj] <- matern.covariance(h, kappa, nu, phi) + tau^2
}
}
return(R)
}
lp <- function(theta, x, y){
kappa <- exp(theta[1])
nu    <- exp(theta[2])
phi   <- exp(theta[3])
beta1 <- theta[4]
beta2 <- theta[5]
m <- beta1 + beta2 * x^2
S <- makeR(x, kappa, nu, phi)
res <- dmvnorm(y, m, S, log=TRUE)
res <- res + sum(dt(c(kappa, phi)/100, 5, log=TRUE))
res <- res + sum(dnorm(c(beta1, beta2), 0, 100, log=TRUE))
return(res)
}
theta0 <- c(0, 0, 0, -0.5, 4)
fit <- Metro_Hastings(lp, theta0, x=x, y=y)
ts,plot(fi$trace[,1])
ts,plot(fi$trace[,1])ts.plot(fit$trace[,1])
ts.plot(fit$trace[,1])
thetap <- fit$trace
kappa <- exp(thetap[,1])
nu    <- exp(thetap[,2])
phi   <- exp(thetap[,3])
phi
lambda <- phi^2*kappa^(2*nu)
ts.plot(lambda)
kappa <- exp(thetap[,1])
nu    <- exp(thetap[,2])
phi   <- exp(thetap[,3])
lambda <- phi^2*kappa^(2*nu)
ts.plot(lambda)
hist(lambda)
hist(lambda, breaks=50)
res <- 0
tmp <- 0
for(i in 0:1000){
tmp <- tmp + dpois(i, m*lambda)
}
m <- 1000
lambda <- 1
res <- 0
tmp <- 0
for(i in 0:1000){
tmp <- tmp + dpois(i, m*lambda)
}
tmp
for(i in 0:2000){
tmp <- tmp + dpois(i, m*lambda)
}
tmp
m <- 1000
lambda <- 1
res <- 0
tmp <- 0
for(i in 0:2000){
tmp <- tmp + dpois(i, m*lambda)
}
tmp
dbinom(0, 1, .4)
dbinom(0, 0, .4)
dbinom(1, 0, .4)
dbinom(5, 0, .4)
z <- 5
res <- 0
tmp <- 0
for(i in 0:2000){
tmp <- tmp + dpois(i, m*lambda)
res <- res + z*dpois(i, m*lambda)*dbinom(z, i, 1/m)/i
}
res
res
for(i in 1:2000){
tmp <- tmp + dpois(i, m*lambda)
res <- res + z*dpois(i, m*lambda)*dbinom(z, i, 1/m)/i
}
m <- 1000
lambda <- 1
z <- 5
res <- 0
tmp <- 0
for(i in 1:2000){
tmp <- tmp + dpois(i, m*lambda)
res <- res + z*dpois(i, m*lambda)*dbinom(z, i, 1/m)/i
}
res
dpois(5, 1)
m <- 1000
lambda <- 1
z <- 5
res <- 0
tmp <- 0
for(i in 1:3000){
tmp <- tmp + dpois(i, m*lambda)
res <- res + z*dpois(i, m*lambda)*dbinom(z, i, 1/m)/i
}
res
185-(299*3)/1000
1185-(299*3)
