tmp = sqrt(1-rho^2)
foo = function(z, mu, sigma, rho){
mu[1]*mu[2] +
(sigma[1]*mu[2] + sigma[2]*mu[1]*rho)*z[1] +
sigma[2]*mu[1]*tmp*z[2] +
sigma[1]*sigma[2]*rho*z[1]^2 +
sigma[1]*sigma[2]*z[1]*z[2]
}
foo = function(z, mu, sigma, rho){
tmp = sqrt(1-rho^2)
mu[1]*mu[2] +
(sigma[1]*mu[2] + sigma[2]*mu[1]*rho)*z[1] +
sigma[2]*mu[1]*tmp*z[2] +
sigma[1]*sigma[2]*rho*z[1]^2 +
sigma[1]*sigma[2]*z[1]*z[2]
}
mean(apply(zz, 1, foo, mu, sigma, rho))
foo = function(z, mu, sigma, rho){
tmp = sqrt(1-rho^2)
mu[1]*mu[2] +
(sigma[1]*mu[2] + sigma[2]*mu[1]*rho)*z[1] +
sigma[2]*mu[1]*tmp*z[2] +
sigma[1]*sigma[2]*rho*z[1]^2 +
sigma[1]*sigma[2]*z[1]*z[2]
}
mean(apply(zz, 1, foo, mu, sigma, rho))
foo = function(z, mu, sigma, rho){
tmp = sqrt(1-rho^2)
mu[1]*mu[2] +
(sigma[1]*mu[2] + sigma[2]*mu[1]*rho)*z[1] +
sigma[2]*mu[1]*tmp*z[2] +
sigma[1]*sigma[2]*rho*z[1]^2 +
sigma[1]*sigma[2]*z[1]*z[2]
}
mean(apply(zz, 1, foo, mu, sigma, rho))
# TESTING
zz <- cbind(rnorm(100000), rnorm(100000))
foo = function(z, mu, sigma, rho){
tmp = sqrt(1-rho^2)
mu[1]*mu[2] +
(sigma[1]*mu[2] + sigma[2]*mu[1]*rho)*z[1] +
sigma[2]*mu[1]*tmp*z[2] +
sigma[1]*sigma[2]*rho*z[1]^2 +
sigma[1]*sigma[2]*z[1]*z[2]
}
mean(apply(zz, 1, foo, mu, sigma, rho))
XX <- mvtnorm::rmvnorm(1e6, mu, Sigma)
ind <- (XX[,1] > a[1]) & (XX[,1] < b[1]) & (XX[,2] > a[2]) & (XX[,2] < b[2])
#XX = XX[ind,]
xy = apply(XX, 1, prod)
mean(xy)
XX <- mvtnorm::rmvnorm(1e6, mu, Sigma)
ind <- (XX[,1] > a[1]) & (XX[,1] < b[1]) & (XX[,2] > a[2]) & (XX[,2] < b[2])
#XX = XX[ind,]
xy = apply(XX, 1, prod)
mean(xy)
XX <- mvtnorm::rmvnorm(1e6, mu, Sigma)
ind <- (XX[,1] > a[1]) & (XX[,1] < b[1]) & (XX[,2] > a[2]) & (XX[,2] < b[2])
#XX = XX[ind,]
xy = apply(XX, 1, prod)
mean(xy)
foo = function(z, mu, sigma, rho){
tmp = sqrt(1-rho^2)
mu[1]*mu[2] +
(sigma[1]*mu[2] + sigma[2]*mu[1]*rho)*z[1] +
sigma[2]*mu[1]*tmp*z[2] +
sigma[1]*sigma[2]*rho*z[1]^2 +
sigma[1]*sigma[2]*z[1]*z[2]
}
mean(apply(zz, 1, foo, mu, sigma, rho))
# Confirm indicator functions
tmp = sqrt(1-rho^2)
tau = rho/tmp
A1  <- (a[1] - mu[1])/sigma[1]
B1  <- (b[1] - mu[1])/sigma[1]
A2  <- (a[1] - mu[1])/sigma[1]/tmp
B2  <- (b[1] - mu[1])/sigma[1]/tmp
ind = (zz[,1] > A1) & (zz[,1] < B1) & (zz[,2] > A2 - tau*zz[,1]) & (zz[,2] < B2 - tau*zz[,1])
bar = zz[ind,]
yy = sigma[2]*(rho*zz[,1] + tmp*zz[,2]) + mu[2]
xx = sigma[1]*zz[,1] + mu[1]
yy = sigma[2]*(rho*zz[,1] + tmp*zz[,2]) + mu[2]
ind = (zz[,1] > A1) & (zz[,1] < B1) & (zz[,2] > A2 - tau*zz[,1]) & (zz[,2] < B2 - tau*zz[,1])
bar = zz[ind,]
xx = sigma[1]*zz[,1] + mu[1]
yy = sigma[2]*(rho*zz[,1] + tmp*zz[,2]) + mu[2]
range(xx)
a
b
exy_bvn <- function(mu, sigma, a, b, rho, nquad=32){
quad_pts <- statmod::gauss.quad(nquad)
nodes <- quad_pts$nodes
weights <- quad_pts$weights
# Compute intermediate params
tmp <- sqrt(1-rho^2)
A1  <- (a[1] - mu[1])/sigma[1]
B1  <- (b[1] - mu[1])/sigma[1]
A2  <- (a[2] - mu[2])/sigma[2]/tmp
B2  <- (b[2] - mu[2])/sigma[2]/tmp
tau <- rho/tmp
# Compute integrals
I1 <- Igq(g0, A1, B1, nodes, weights,
D=B2, tau=tau, k=0) -
Igq(g0, A1, B1, nodes, weights,
D=A2, tau=tau, k=0)
I2 <- Igq(g0, A1, B1, nodes, weights,
D=B2, tau=tau, k=1) -
Igq(g0, A1, B1, nodes, weights,
D=A2, tau=tau, k=1)
I3 <- Igq(g1, A1, B1, nodes, weights,
D=A2, tau=tau, k=0) -
Igq(g1, A1, B1, nodes, weights,
D=B2, tau=tau, k=0)
I4 <- Igq(g0, A1, B1, nodes, weights,
D=A2, tau=tau, k=2) -
Igq(g0, A1, B1, nodes, weights,
D=B2, tau=tau, k=2)
I5 <- Igq(g1, A1, B1, nodes, weights,
D=B2, tau=tau, k=1) -
Igq(g1, A1, B1, nodes, weights,
D=A2, tau=tau, k=1)
res <- mu[1]*mu[2]*I1 +
(sigma[1]*mu[2] + sigma[2]*mu[1]*rho)*I2 +
sigma[2]*mu[1]*tmp*I3 +
sigma[1]*sigma[2]*rho*I4 +
sigma[1]*sigma[2]*tmp
return(res)
}
mu <- c(-0.5, 1.2)
sigma <- c(1.2, 0.7)
a <- c(-2, -4)
b <- c(1, 2)
rho = 0.25
Sigma <- matrix(c(sigma[1]^2, rho*prod(sigma), rho*prod(sigma), sigma[2]^2), nrow=2, byrow=TRUE)
exy_bvn(mu, sigma, a, b, rho)
XX <- mvtnorm::rmvnorm(1e6, mu, Sigma)
ind <- (XX[,1] > a[1]) & (XX[,1] < b[1]) & (XX[,2] > a[2]) & (XX[,2] < b[2])
#XX = XX[ind,]
xy = apply(XX, 1, prod)
mean(xy)
exy_bvn <- function(mu, sigma, a, b, rho, nquad=32){
quad_pts <- statmod::gauss.quad(nquad)
nodes <- quad_pts$nodes
weights <- quad_pts$weights
# Compute intermediate params
tmp <- sqrt(1-rho^2)
A1  <- (a[1] - mu[1])/sigma[1]
B1  <- (b[1] - mu[1])/sigma[1]
A2  <- (a[2] - mu[2])/sigma[2]/tmp
B2  <- (b[2] - mu[2])/sigma[2]/tmp
tau <- rho/tmp
# Compute integrals
I1 <- Igq(g0, A1, B1, nodes, weights,
D=B2, tau=tau, k=0) -
Igq(g0, A1, B1, nodes, weights,
D=A2, tau=tau, k=0)
I2 <- Igq(g0, A1, B1, nodes, weights,
D=B2, tau=tau, k=1) -
Igq(g0, A1, B1, nodes, weights,
D=A2, tau=tau, k=1)
I3 <- Igq(g1, A1, B1, nodes, weights,
D=A2, tau=tau, k=0) -
Igq(g1, A1, B1, nodes, weights,
D=B2, tau=tau, k=0)
I4 <- Igq(g0, A1, B1, nodes, weights,
D=A2, tau=tau, k=2) -
Igq(g0, A1, B1, nodes, weights,
D=B2, tau=tau, k=2)
I5 <- Igq(g1, A1, B1, nodes, weights,
D=B2, tau=tau, k=1) -
Igq(g1, A1, B1, nodes, weights,
D=A2, tau=tau, k=1)
res <- mu[1]*mu[2]*I1 +
(sigma[1]*mu[2] + sigma[2]*mu[1]*rho)*I2 +
sigma[2]*mu[1]*tmp*I3 +
sigma[1]*sigma[2]*rho*I4 +
sigma[1]*sigma[2]*tmp
return(res)
}
mu <- c(-0.5, 1.2)
sigma <- c(1.2, 0.7)
a <- c(-2, -4)
b <- c(1, 2)
rho = 0.25
Sigma <- matrix(c(sigma[1]^2, rho*prod(sigma), rho*prod(sigma), sigma[2]^2), nrow=2, byrow=TRUE)
exy_bvn(mu, sigma, a, b, rho)
XX <- mvtnorm::rmvnorm(1e6, mu, Sigma)
ind <- (XX[,1] > a[1]) & (XX[,1] < b[1]) & (XX[,2] > a[2]) & (XX[,2] < b[2])
#XX = XX[ind,]
xy = apply(XX, 1, prod)
mean(xy)
# TESTING
zz <- cbind(rnorm(100000), rnorm(100000))
# Confirmed relationship between z and y
foo = function(z, mu, sigma, rho){
tmp = sqrt(1-rho^2)
mu[1]*mu[2] +
(sigma[1]*mu[2] + sigma[2]*mu[1]*rho)*z[1] +
sigma[2]*mu[1]*tmp*z[2] +
sigma[1]*sigma[2]*rho*z[1]^2 +
sigma[1]*sigma[2]*z[1]*z[2]
}
mean(apply(zz, 1, foo, mu, sigma, rho))
# Confirm indicator functions
tmp = sqrt(1-rho^2)
tau = rho/tmp
A1  <- (a[1] - mu[1])/sigma[1]
B1  <- (b[1] - mu[1])/sigma[1]
A2  <- (a[1] - mu[1])/sigma[2]/tmp
B2  <- (b[1] - mu[1])/sigma[2]/tmp
ind = (zz[,1] > A1) & (zz[,1] < B1) & (zz[,2] > A2 - tau*zz[,1]) & (zz[,2] < B2 - tau*zz[,1])
bar = zz[ind,]
xx = sigma[1]*zz[,1] + mu[1]
yy = sigma[2]*(rho*zz[,1] + tmp*zz[,2]) + mu[2]
range(xx)
a
# Confirm indicator functions
tmp = sqrt(1-rho^2)
tau = rho/tmp
A1  <- (a[1] - mu[1])/sigma[1]
B1  <- (b[1] - mu[1])/sigma[1]
A2  <- (a[2] - mu[2])/sigma[2]/tmp
B2  <- (b[2] - mu[2])/sigma[2]/tmp
ind = (zz[,1] > A1) & (zz[,1] < B1) & (zz[,2] > A2 - tau*zz[,1]) & (zz[,2] < B2 - tau*zz[,1])
bar = zz[ind,]
xx = sigma[1]*zz[,1] + mu[1]
yy = sigma[2]*(rho*zz[,1] + tmp*zz[,2]) + mu[2]
range(xx)
exy_bvn <- function(mu, sigma, a, b, rho, nquad=32){
quad_pts <- statmod::gauss.quad(nquad)
nodes <- quad_pts$nodes
weights <- quad_pts$weights
# Compute intermediate params
tmp <- sqrt(1-rho^2)
A1  <- (a[1] - mu[1])/sigma[1]
B1  <- (b[1] - mu[1])/sigma[1]
A2  <- (a[2] - mu[2])/sigma[2]/tmp
B2  <- (b[2] - mu[2])/sigma[2]/tmp
tau <- rho/tmp
# Compute integrals
I1 <- Igq(g0, A1, B1, nodes, weights,
D=B2, tau=tau, k=0) -
Igq(g0, A1, B1, nodes, weights,
D=A2, tau=tau, k=0)
I2 <- Igq(g0, A1, B1, nodes, weights,
D=B2, tau=tau, k=1) -
Igq(g0, A1, B1, nodes, weights,
D=A2, tau=tau, k=1)
I3 <- Igq(g1, A1, B1, nodes, weights,
D=A2, tau=tau, k=0) -
Igq(g1, A1, B1, nodes, weights,
D=B2, tau=tau, k=0)
I4 <- Igq(g0, A1, B1, nodes, weights,
D=B2, tau=tau, k=2) -
Igq(g0, A1, B1, nodes, weights,
D=A2, tau=tau, k=2)
I5 <- Igq(g1, A1, B1, nodes, weights,
D=A2, tau=tau, k=1) -
Igq(g1, A1, B1, nodes, weights,
D=B2, tau=tau, k=1)
res <- mu[1]*mu[2]*I1 +
(sigma[1]*mu[2] + sigma[2]*mu[1]*rho)*I2 +
sigma[2]*mu[1]*tmp*I3 +
sigma[1]*sigma[2]*rho*I4 +
sigma[1]*sigma[2]*tmp
return(res)
}
mu <- c(-0.5, 1.2)
sigma <- c(1.2, 0.7)
a <- c(-2, -4)
b <- c(1, 2)
rho = 0.25
Sigma <- matrix(c(sigma[1]^2, rho*prod(sigma), rho*prod(sigma), sigma[2]^2), nrow=2, byrow=TRUE)
exy_bvn(mu, sigma, a, b, rho)
XX <- mvtnorm::rmvnorm(1e6, mu, Sigma)
ind <- (XX[,1] > a[1]) & (XX[,1] < b[1]) & (XX[,2] > a[2]) & (XX[,2] < b[2])
#XX = XX[ind,]
xy = apply(XX, 1, prod)
mean(xy)
range(yy)
a
b
range(xx)
install.packages("veccTMVN")
install.packages("VeccTMVN")
library(VeccTMVN)
?Vecc_reorder
p <- 10
a <- runif(p, -3, 0)
b <- runif(p, 0, 3)
i=j = 1
i
j
runif(1, -1, 1)*(i != j) + (i == j)
j = 2
runif(1, -1, 1)*(i != j) + (i == j)
p <- 10
a <- runif(p, -3, 0)
b <- runif(p, 0, 3)
mu <- rnorm(p)
Sigma <- matrix(NA, nrow=p, ncol=p)
for(i in 2:nrow(p)){
for(j in 1:i){
rho <- runif(1, -.9, .9)*(i != j) + (i == j)
sigma1 <- sqrt(runif(1, 0.5, 2))
sigma2 <- sqrt(runif(1, 0.5, 2))
Sigma[i,j] <- Sigma[j,i] <- rho*sigma1*sigma2
}
}
for(i in 2:p){
for(j in 1:i){
rho <- runif(1, -.9, .9)*(i != j) + (i == j)
sigma1 <- sqrt(runif(1, 0.5, 2))
sigma2 <- sqrt(runif(1, 0.5, 2))
Sigma[i,j] <- Sigma[j,i] <- rho*sigma1*sigma2
}
}
Sigma
solve(Sigma)
Sigma
image(Sigma)
solve(Sigma)
Sigma - t(Sigma)
Sigma <- matrix(NA, nrow=p, ncol=p)
for(i in 1:p){
for(j in 1:i){
rho <- runif(1, -.9, .9)*(i != j) + (i == j)
sigma1 <- sqrt(runif(1, 0.5, 2))
sigma2 <- sqrt(runif(1, 0.5, 2))
Sigma[i,j] <- Sigma[j,i] <- rho*sigma1*sigma2
}
}
solve(Sigma)
library(VeccTMVN)
set.seed(1298012)
p <- 10
a <- runif(p, -3, 0)
b <- runif(p, 0, 3)
mu <- rnorm(p)
Sigma <- matrix(NA, nrow=p, ncol=p)
for(i in 1:p){
for(j in 1:i){
rho <- runif(1, -.9, .9)*(i != j) + (i == j)
sigma1 <- sqrt(runif(1, 0.5, 2))
sigma2 <- sqrt(runif(1, 0.5, 2))
Sigma[i,j] <- Sigma[j,i] <- rho*sigma1*sigma2
}
}
image(Sigma)
Sigma
Vecc_reorder(a, b, m=3, covMat=Sigma)
?Vecc_reorder
?get_sp_inv_chol
vecc = Vecc_reorder(a, b, m=3, covMat=Sigma)
V = get_sp_inv_chol(Sigma, vecc$nn)
V
V = get_sp_inv_chol(Sigma)
V = get_sp_inv_chol(Sigma, vecc$nn)
V
vecc = Vecc_reorder(a, b, m=5, covMat=Sigma)
vecc = Vecc_reorder(a, b, m=5, covMat=Sigma)
vecc = Vecc_reorder(a, b, m=1, covMat=Sigma)
vecc
library(GpGp)
n1 <- 10
n2 <- 10
n <- n1 * n2
locs <- as.matrix(expand.grid((1:n1) / n1, (1:n2) / n2))
covparms <- c(2, 0.3, 0)
cov_mat <- GpGp::matern15_isotropic(covparms, locs)
m <- 30
NNarray <- GpGp::find_ordered_nn(locs, m = m)
# Vecchia approx --------------------------------
U_Vecc <- get_sp_inv_chol(cov_mat, NNarray)
U <- solve(chol(cov_mat))
cat("Frobenius norm of the difference is", sqrt(sum((U - U_Vecc)^2)))
NNarray
vecc = Vecc_reorder(a, b, m=1, covMat=Sigma)
V = get_sp_inv_chol(Sigma, vecc$nn)
V
vecc = Vecc_reorder(a, b, m=2, covMat=Sigma)
V = get_sp_inv_chol(Sigma, vecc$nn)
V
vecc = Vecc_reorder(a, b, m=1, covMat=Sigma)
V = get_sp_inv_chol(Sigma, vecc$nn)
V
image(V)
solve(V%*%t(V))
image(solve(V%*%t(V)))
image(Sigma)
image(Sigma)
image(solve(V%*%t(V)))
par(mfrow=c(1,2))
image(Sigma)
image(solve(V%*%t(V)))
image(Sigma, main="Full Sigma")
image(solve(V%*%t(V)), main="Vecchia (m=1)")
vecc = Vecc_reorder(a, b, m=2, covMat=Sigma)
V = get_sp_inv_chol(Sigma, vecc$nn)
V = get_sp_inv_chol(Sigma, vecc$nn)
V[which(is.na(V))] <- 0
par(mfrow=c(1,2))
image(Sigma, main="Full Sigma")
image(solve(V%*%t(V)), main="Vecchia (m=1)")
vecc = Vecc_reorder(a, b, m=1, covMat=Sigma)
V = get_sp_inv_chol(Sigma, vecc$nn)
par(mfrow=c(1,2))
image(Sigma, main="Full Sigma")
image(solve(V%*%t(V)), main="Vecchia (m=1)")
vecc
diag(V)^(-2)
image(vecc$A)
class(vecc$A)
as.matrix(vecc$A)
image(as.matrix(vecc$A))
image(as.matrix(vecc$A)[vecc$order,])
diag(V)^(-2)
diag(Sigma)
diag(Sigma)[vecc$order]
plot(diag(Sigma)[vecc$order], diag(V)^(-2))
abline(0, 1)
Sigma[vecc$order, vecc$order]
a <- a[vecc$order]
b <- b[vecc$order]
Sigma <- Sigma[vecc$order, vecc$order]
image(Sigma)
vecc2 <- Vecc_reorder(a, b, covMat=Sigma)
vecc2 <- Vecc_reorder(a, b, m=1, covMat=Sigma)
vecc2
vecc2$A
image(vecc2$A)
image(as.matrix(vecc2$A))
?bass
library(BASS
)
?bass
lam = rgamma(10000, 10, 10)
mean(lam)
M = rpois(lam, lambda =lam)
mean(M)
M2 = rnbinom(10000, M+10, prob=10/11)
mean(M)
mean(M2)
var(M)
var(M2)
a = 2
b = 0.5
lam = rgamma(10000, 10, 10)
M = rpois(lam, lambda =lam)
M2 = rnbinom(10000, M+10, prob=10/11)
mean(M)
mean(M2)
var(M)
var(M2)
M2 = rnbinom(10000, 10, prob=10/11)
mean(M2)
mean(M)
var(M)
var(M2)
lam = rgamma(10000, 0.2, 1.4)
M = rpois(lam, lambda =lam)
lam = rgamma(10000, 2, 0.8)
M = rpois(lam, lambda =lam)
M2 = rnbinom(10000, 2, prob=0.8/1.8)
M
mean(M)
mean(M2)
var(M)
var(M2)
M2 = rnbinom(10000, 2.5, prob=0.8/1.8)
M2
mean(M2)
M2 = rnbinom(10000, 2, prob=0.8/1.8)
mean(M2)
p <- 100
p0 <- 48
eta <- abs(1e3*rt(p, 1))
eta
max(eta)
hist(eta)
eta <- abs(1e3*rt(p, 1))
eta
hist(eta)
make_weights(eta, p0)
#'
#' eta[1:3] <- 1e5
#' w <- make_weights(eta, p0)
#' sum(w)
#' w
#'
#' eta <- abs(1e3*rt(p, 3))
#' w <- make_weights(eta, p0)
#' sum(w)
#' w
make_weights <- function(eta, p0, alpha=2, epsilon=1, num_passes=3){
p <- length(eta)
v <- (eta^alpha + epsilon)/sum((eta^alpha + epsilon))*p0/p
delta <- 0
for(i in 1:num_passes){
beta <- mean((log(p0 + delta) - log(p))/log(v))
delta <- delta + p0 - sum(v^beta)
}
return(v^beta)
}
make_weights(eta, p0)
sum(make_weights(eta, p0))
which.max(eta)
eta[84] <- eta[84]*1e8
make_weights(eta, p0)
sum(make_weights(eta, p0))
eta[84]
(make_weights(eta, p0))[84]
