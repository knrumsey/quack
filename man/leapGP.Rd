% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/leapGP.R
\name{leapGP}
\alias{leapGP}
\title{Localized Ensemble of Approximate Gaussian Processes}
\usage{
leapGP(
  Xnew,
  X,
  Y,
  H = NA,
  scale = F,
  n = NA,
  frac = FALSE,
  start = NA,
  verbose = TRUE,
  justdoit = FALSE,
  ...
)
}
\arguments{
\item{X}{a matrix of training locations (1 row for each training instance)}

\item{Y}{a vector of training responses (length(y) == nrow(X))}

\item{H}{the number of prediction hubs desired. Defaults to ceiling(sqrt(length(Y))).}

\item{scale}{logical. Do we want the scale parameter to be returned for predictions? If TRUE,
the matrix K^{-1} will be stored for each hub.}

\item{n}{local neighborhood size}

\item{frac}{logical. If TRUE, information is returned about the fraction of training points which are in their own prediction neighborhoods.}

\item{verbose}{logical. Deault is FALSE}

\item{justdoit}{logical. Force leapGP to run using specified parameters (may be incredibly time consuming).}

\item{...}{optional arguments to be passed to laGP()}

\item{iso}{boolean. Is correlation function isotropic? (Current version ignores this argument)}
}
\value{
a univariate prediction and an updated list of hubs. Also returns scale parameter if scale=TRUE
}
\description{
A wrapper for combining training and prediction for leapGP
}
\examples{
Xnew <- matrix(runif(100), nrow=50, ncol=2)
X <- matrix(runif(100), nrow=50, ncol=2)
Y <- apply(X, 1, prod)
preds1 <- leapGP(Xnew, X, Y)

#Or equivalently
leap <- leapGP_build(X, Y)
preds2 <- rep(NA, 100)
for(i in 1:100){
   preds2[i] <- leapGP_predict(leap, Xnew[i,])
}

#Or used with slapGP
leap <- leapGP_synch(leap, rho=0.95)
hubs <- leap$hubs
preds3 <- rep(NA, 100)
for(i in 1:100){
   emulator <- slapGP(Xnew[i,], X, Y, hubs=hubs)
   preds3[m] <- emulator$pred
   hubs <- emulator$hubs
}
}
