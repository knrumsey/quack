% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/slapGP.R
\name{slapGP}
\alias{slapGP}
\title{Sequence of Local Approximate Gaussian Processes}
\usage{
slapGP(
  Xnew,
  X,
  Y,
  rho = 0.95,
  hubs = list(),
  scale = F,
  iso = TRUE,
  n = NA,
  start = NA,
  ...
)
}
\arguments{
\item{Xnew}{the location at which prediction is requested}

\item{X}{a matrix of training locations (1 row for each training instance)}

\item{Y}{a vector of training responses (length(y) == nrow(X))}

\item{rho}{parameter controlling time-accuracy tradeoff (default = 0.95)}

\item{hubs}{a list of current prediction hubs}

\item{scale}{logical. Do we want the scale parameter to be returned for predictions? If TRUE,
the matrix K^{-1} will be stored for each hub.}

\item{iso}{logical. Is correlation function isotropic? (Currently not supported)}

\item{n}{local neighborhood size}

\item{start}{number of starting points for neighborhood (between 6 and n inclusive)}

\item{...}{optional arguments to be passed to laGP()}
}
\value{
a univariate prediction and an updated list of hubs. Also returns scale parameter if scale=TRUE
}
\description{
This function is a modification of the LA-GP framework of Gramacy and Apley
designed for cases where parallel predictions are not possible (i.e. MCMC).
The slapGP framework offers users a time-accuracy tradeoff based on the rho parameter.
}
\examples{

hubs <- list()
X <- matrix(runif(100), nrow=50, ncol=2)
Y <- apply(X, 1, prod)
preds <- rep(NA, 1000)
for(i in 1:1000){
   Xnew <- runif(2)
   emulator <- slapGP(Xnew, X, Y, hubs=hubs)
   hubs <- emulator$hubs
   preds[i] <- emulator$pred
}
}
